<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>陣列方法：every()</title>
      <link href="/2024/07/28/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Aevery/"/>
      <url>/2024/07/28/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Aevery/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>every()</code> 方法會判斷所有元素是否都符合條件，在判斷過程中只要 callback function 回傳 <code>false</code> 就會停止遍歷，否則代表全部元素都符合條件，回傳 <code>true</code>。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>every()</code> 方法時要傳入一個 callback function，該 function 可傳入三個參數：</p><ol><li><strong>currentValue (必要)</strong> ：原陣列目前迭代挑到的元素。</li><li><strong>index (選擇性)</strong> ：原陣列目前迭代挑到的元素的索引。</li><li><strong>array (選擇性)</strong> ：原陣列本身。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> &#123;  <span class="hljs-comment">// do something</span>&#125;)</code></pre><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>檢查陣列中的元素是否都大於 10</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isBigEnough</span>(<span class="hljs-params">element, index, array</span>) &#123;  <span class="hljs-keyword">return</span> element &gt;= <span class="hljs-number">10</span>;&#125;[<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].<span class="hljs-title function_">every</span>(isBigEnough); <span class="hljs-comment">// false</span>[<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].<span class="hljs-title function_">every</span>(isBigEnough); <span class="hljs-comment">// true</span></code></pre><ol start="2"><li>判斷一個陣列中的元素是否為另一個陣列的子集</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isSubset</span> = (<span class="hljs-params">array1, array2</span>) =&gt;  array2.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> array1.<span class="hljs-title function_">includes</span>(element));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isSubset</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>])); <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isSubset</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>])); <span class="hljs-comment">// false</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 陣列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 陣列 </tag>
            
            <tag> 陣列方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列方法：find()</title>
      <link href="/2024/07/27/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Afind/"/>
      <url>/2024/07/27/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Afind/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>find()</code> 方法會回傳第一個滿足條件的元素 ( 只回傳一個元素 )，否則會回傳 <code>undefined</code>。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>find()</code> 方法時要傳入一個 callback function，該 function 可傳入三個參數：</p><ol><li><strong>currentValue (必要)</strong> ：原陣列目前迭代挑到的元素。</li><li><strong>index (選擇性)</strong> ：原陣列目前迭代挑到的元素的索引。</li><li><strong>array (選擇性)</strong> ：原陣列本身。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> &#123;  <span class="hljs-comment">// do something</span>&#125;)</code></pre><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>在陣列中查找某個符合條件的物件元素。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> inventory = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;apples&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">2</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bananas&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">0</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cherries&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">5</span> &#125;,];<span class="hljs-keyword">function</span> <span class="hljs-title function_">isCherries</span>(<span class="hljs-params">fruit</span>) &#123;  <span class="hljs-keyword">return</span> fruit.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;cherries&quot;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(inventory.<span class="hljs-title function_">find</span>(isCherries));<span class="hljs-comment">// &#123; name: &#x27;cherries&#x27;, quantity: 5 &#125;</span></code></pre><ol start="2"><li>在陣列中找質數</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">element, index, array</span>) &#123;  <span class="hljs-keyword">var</span> start = <span class="hljs-number">2</span>;  <span class="hljs-keyword">while</span> (start &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(element)) &#123;    <span class="hljs-keyword">if</span> (element % start++ &lt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/* start 變數會在判斷完後才 + 1 */</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> element &gt; <span class="hljs-number">1</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>].<span class="hljs-title function_">find</span>(isPrime)); <span class="hljs-comment">// undefined, not found</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>].<span class="hljs-title function_">find</span>(isPrime)); <span class="hljs-comment">// 5</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 陣列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 陣列 </tag>
            
            <tag> 陣列方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列方法：filter()</title>
      <link href="/2024/07/27/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Afilter/"/>
      <url>/2024/07/27/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Afilter/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>filter()</code> 方法會將陣列中的所有元素，依序地傳入一次至 callback function 中，並將回傳值為 Truthy 的元素建構成一個新的陣列，也就是篩選出符合條件的元素出來，並將這些元素塞進一個新的陣列裡。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>filter()</code> 方法時要傳入一個 callback function，該 function 可傳入三個參數：</p><ol><li><strong>currentValue (必要)</strong> ：原陣列目前迭代挑到的元素。</li><li><strong>index (選擇性)</strong> ：原陣列目前迭代挑到的元素的索引。</li><li><strong>array (選擇性)</strong> ：原陣列本身。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> &#123;  <span class="hljs-comment">// do something</span>&#125;)</code></pre><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>過濾小於 10 的數字。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isBigEnough</span>(<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">let</span> filtered = [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].<span class="hljs-title function_">filter</span>(isBigEnough);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filtered); <span class="hljs-comment">// 12, 130, 44</span></code></pre><ol start="2"><li>過濾 JSON 檔中無效的項目<br>以下範例會用 filter() 把 id 屬性為非數值型別的項目過濾掉。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">var</span> arr = [  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">15</span> &#125;,  &#123; <span class="hljs-attr">id</span>: -<span class="hljs-number">1</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">12.2</span> &#125;,  &#123;&#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-literal">null</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-title class_">NaN</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;undefined&quot;</span> &#125;,];<span class="hljs-keyword">function</span> <span class="hljs-title function_">isNumber</span>(<span class="hljs-params">obj</span>) &#123;  <span class="hljs-keyword">return</span> obj !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;number&quot;</span> &amp;&amp; !<span class="hljs-built_in">isNaN</span>(obj);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">filterByID</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNumber</span>(item.<span class="hljs-property">id</span>)) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">var</span> arrByID = arr.<span class="hljs-title function_">filter</span>(filterByID);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;過濾好的陣列\n&quot;</span>, arrByID);<span class="hljs-comment">// 過濾好的陣列</span><span class="hljs-comment">// [&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 陣列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 陣列 </tag>
            
            <tag> 陣列方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列方法：reduce()</title>
      <link href="/2024/07/26/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Areduce/"/>
      <url>/2024/07/26/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Areduce/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>reduce()</code> 方法會針每一個目前迭代到的陣列元素 ( 空值除外 )，去執行 callback function，而 callback function 會接受 4 個參數：</p><ul><li><strong>accumulator</strong> ：累加器 ( 必填 )</li><li><strong>currentValue</strong> ：目前迭代到的元素 ( 必填 )</li><li><strong>index</strong> ：目前迭代到的元素的索引 ( 選擇性 )</li><li><strong>array</strong> ：陣列本身 ( 選擇性 )</li></ul><p>又其中 <code>accumulator</code> 與 <code>currentValue</code> 的初始值會有兩種不同的情況，呼叫 <code>reduce()</code> 時，有無提供 <code>initialValue</code>？（建議都要提供 <code>initialValue</code>，比較安全，可參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#%E6%8F%8F%E8%BF%B0">MDN Array.prototype.reduce()</a>）</p><ol><li><p>有提供 <code>initialValue</code>，則 <code>accumulator</code> 一開始的值會等於 <code>initialValue</code>，<code>currentValue</code> 會等於陣列中的第一個元素值。</p></li><li><p>未提供 <code>initialValue</code>，則 <code>accumulator</code> 一開始的值會等於陣列中的第一個元素值，<code>currentValue</code> 會等於陣列中的第二個元素值。</p></li></ol><p>然後在每一次迭代中，callback function 執行完後都會吐一個值，此值會成為下一次迭代的 <code>accumulator</code>的值。</p><p>當所有迭代都完成後，最後一次吐出來的 <code>accumulator</code> 的值，會是一個「加總」、「集合」等等。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>reduce()</code> 方法時可以帶入一個 <code>initialValue</code> 以及要傳入一個 callback function，該 function 可傳入四個參數：</p><ul><li><strong>accumulator</strong> ：累加器 ( 必填 )</li><li><strong>currentValue</strong> ：目前迭代到的元素 ( 必填 )</li><li><strong>index</strong> ：目前迭代到的元素的索引 ( 選擇性 )</li><li><strong>array</strong> ：陣列本身 ( 選擇性 )</li></ul><pre><code class="hljs JS"><span class="hljs-comment">// 傳統函式 ( 此例未提供 initialValue )</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(  <span class="hljs-keyword">function</span> (<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) &#123;    <span class="hljs-keyword">return</span> accumulator + currentValue;  &#125;,);<span class="hljs-comment">// 箭頭函式 ( 此例有提供 initialValue， initialValue 值為 10)</span>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> accumulator + currentValue;&#125;, <span class="hljs-number">10</span>);</code></pre><p>將上述的箭頭函式的例子，攤開每一次迭代的狀況，就如下表格：</p><table><thead><tr><th>callback 次數</th><th>accumulator</th><th>currentValue</th><th>currentIndex</th><th>array</th><th>return value</th></tr></thead><tbody><tr><td>first</td><td>10</td><td>2</td><td>0</td><td>[2, 4, 6, 8, 10]</td><td>10 + 2 &#x3D; 12</td></tr><tr><td>second</td><td>12</td><td>4</td><td>1</td><td>[2, 4, 6, 8, 10]</td><td>10 + 4 &#x3D; 14</td></tr><tr><td>third</td><td>14</td><td>6</td><td>2</td><td>[2, 4, 6, 8, 10]</td><td>14 + 6 &#x3D; 20</td></tr><tr><td>fourth</td><td>20</td><td>8</td><td>3</td><td>[2, 4, 6, 8, 10]</td><td>20 + 8 &#x3D; 28</td></tr><tr><td>fifth</td><td>28</td><td>10</td><td>4</td><td>[2, 4, 6, 8, 10]</td><td>28 + 10 &#x3D; 38</td></tr></tbody></table><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>加總所有陣列之元素值</li></ol><pre><code class="hljs JS"><span class="hljs-comment">// 傳統函式</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> accumulator + currentValue;&#125;, <span class="hljs-number">0</span>);<span class="hljs-comment">// 0 + 0 + 1 + 2 + 3 + 4 = 10，sum = 10。</span><span class="hljs-comment">// 箭頭函式</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> accumulator + currentValue;&#125;, <span class="hljs-number">0</span>);<span class="hljs-comment">// 0 + 0 + 1 + 2 + 3 + 4 = 10，sum = 10。</span></code></pre><ol start="2"><li>計算陣列中每個元素的重複次數，並以物件的形式顯示</li></ol><pre><code class="hljs JS"><span class="hljs-comment">// 傳統函式</span><span class="hljs-keyword">let</span> names = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Tiff&quot;</span>, <span class="hljs-string">&quot;Bruce&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>];<span class="hljs-keyword">let</span> countedNames = names.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">allNames, name</span>) &#123;  <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> allNames) &#123;    allNames[name]++;  &#125; <span class="hljs-keyword">else</span> &#123;    allNames[name] = <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> allNames;&#125;, &#123;&#125;);<span class="hljs-comment">// countedNames is: &#123; &#x27;Alice&#x27;: 2, &#x27;Bob&#x27;: 1, &#x27;Tiff&#x27;: 1, &#x27;Bruce&#x27;: 1 &#125;</span><span class="hljs-comment">// 箭頭函式</span><span class="hljs-keyword">let</span> names = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Tiff&quot;</span>, <span class="hljs-string">&quot;Bruce&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>];<span class="hljs-keyword">let</span> countedNames = names.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">allNames, name</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> allNames) &#123;    allNames[name]++;  &#125; <span class="hljs-keyword">else</span> &#123;    allNames[name] = <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> allNames;&#125;, &#123;&#125;);<span class="hljs-comment">// countedNames is: &#123; &#x27;Alice&#x27;: 2, &#x27;Bob&#x27;: 1, &#x27;Tiff&#x27;: 1, &#x27;Bruce&#x27;: 1 &#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 陣列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 陣列 </tag>
            
            <tag> 陣列方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列方法：map()</title>
      <link href="/2024/07/25/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Amap/"/>
      <url>/2024/07/25/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Amap/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>map()</code> 方法會將陣列中的所有元素，依序地傳入一次至 callback function 中，每一次的傳入都會 return 一個新的元素，並以此 callback function return 的所有新元素建構一個新的陣列。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>map()</code> 方法時要傳入一個 callback function，該 function 可傳入三個參數：</p><ol><li><strong>currentValue (必要)</strong> ：原陣列目前迭代挑到的元素。</li><li><strong>index (選擇性)</strong> ：原陣列目前迭代挑到的元素的索引。</li><li><strong>array (選擇性)</strong> ：原陣列本身。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> &#123;  <span class="hljs-comment">// do something</span>&#125;)</code></pre><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>回傳元素的平方</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * item);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [1, 4, 9, 16, 25]</span></code></pre><ol start="2"><li>將元素開根號</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>];<span class="hljs-keyword">var</span> roots = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">sqrt</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(roots); <span class="hljs-comment">// [1, 2, 3]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 陣列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 陣列 </tag>
            
            <tag> 陣列方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>型別 3：型別比較</title>
      <link href="/2024/07/23/%E5%9E%8B%E5%88%A5-3%EF%BC%9A%E5%9E%8B%E5%88%A5%E6%AF%94%E8%BC%83/"/>
      <url>/2024/07/23/%E5%9E%8B%E5%88%A5-3%EF%BC%9A%E5%9E%8B%E5%88%A5%E6%AF%94%E8%BC%83/</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 中，有兩種型別比較，分別是<strong>寬鬆比較</strong>和<strong>嚴格比較</strong>。</p><h2 id="嚴格比較的規則"><a href="#嚴格比較的規則" class="headerlink" title="嚴格比較的規則"></a>嚴格比較的規則</h2><p><strong>嚴格比較的規則：比較的兩個運算元，必須要有相同的「型別」和相同的「值」，才會回傳 true。</strong></p><p>不過也有部分屬於例外，以下是一些容易被混淆的案例：</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>);                     <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>);                       <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> === <span class="hljs-literal">null</span>);              <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; === &#123;&#125;);                       <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>) === <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// false</span></code></pre><ul><li><strong>NaN &#x3D;&#x3D;&#x3D; NaN</strong>：NaN (Not A Number) 在嚴格比較時，會不等於任何值，因此與 NaN 比較時，一樣會獲得 false 的結果；如果要判斷是否為 NaN，可改用 isNaN() 這個方法。</li><li><strong>+0 &#x3D;&#x3D;&#x3D; -0</strong>：正 0 跟負 0 都會被視為 0，因此在嚴格比較時，會獲得 true 的結果。</li><li><strong>undefined &#x3D;&#x3D;&#x3D; null</strong>：雖然這兩個有點像，但兩者根本是不同的型別，所以嚴格比較時，會獲得 false 的結果。</li><li>{} &#x3D;&#x3D;&#x3D; {}：物件在比較時是比較兩者的「參考位址」，所以兩個物件就算其結構完全一致，也會得到 false 的結果。</li><li>new Number(1) &#x3D;&#x3D;&#x3D; new Number(1)：當使用 new 運算子建立原型時，實際上所建立的型別是物件型別，因此兩個物件相比，都會得到 false 的結果。</li></ul><h2 id="寬鬆比較的規則"><a href="#寬鬆比較的規則" class="headerlink" title="寬鬆比較的規則"></a>寬鬆比較的規則</h2><p><strong>寬鬆比較的規則複雜一點，不同型別的比對規則都不太一樣。</strong></p><h3 id="Number、String、Boolean-型別的寬鬆比較規則"><a href="#Number、String、Boolean-型別的寬鬆比較規則" class="headerlink" title="Number、String、Boolean 型別的寬鬆比較規則"></a><span style="color:white; background-color: #2a2936; padding: 5px">Number、String、Boolean 型別的寬鬆比較規則</span></h3><p>數值、字串、布林這三者之間，在進行寬鬆比較的時候，<u>如果運算元並非相同型別，則會統一轉型為 <code>Number</code> 進行比對</u> 。<br>因此在比對的時候，可以假想將兩個比較值都套上 <code>Number()</code>，<br>例如：Number(‘1’) &#x3D; 1、Number(true) &#x3D; 1、Number(false) &#x3D; 0，<br>來看一些基本範例：</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-number">1</span>);       <span class="hljs-comment">// true，相當於 Number(&#x27;1&#x27;) == 1 =&gt; true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-literal">true</span>);    <span class="hljs-comment">// true，相當於 Number(&#x27;1&#x27;) == Number(true) =&gt; true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-literal">false</span>);   <span class="hljs-comment">// true，相當於 Number(&#x27;0&#x27;) == Number(false) =&gt; true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span> == <span class="hljs-literal">true</span>);   <span class="hljs-comment">// false，因為 Number(&#x27;2&#x27;) = 2，但是 Number(true) = 1，所以不相等</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">false</span> == <span class="hljs-number">0</span>);     <span class="hljs-comment">// true，相當於 Number(false) == 0 =&gt; true</span></code></pre><ul><li>‘1’ &#x3D;&#x3D; 1：因為 ‘1’ 會轉型別為數值 1，所以比對結果為 true。</li><li>‘1’ &#x3D;&#x3D; true：因為 ‘1’ 會轉型別為數值 1、true 會轉型別為數值 1，所以比對結果為 true。</li><li>‘0’ &#x3D;&#x3D; false：因為 ‘0’ 會轉型別為數值 0、false 會轉型別為數值 0，所以比對結果為 true。</li><li>‘2’ &#x3D;&#x3D; true：因為 ‘2’ 會轉型別為數值 2，true 會轉型別為數值 1，所以比對結果為 false。</li><li>false &#x3D;&#x3D; 0：因為 false 會轉型別數值 0，所以比對結果為 true。</li></ul><p><strong><u>記得當你遇到數值、字串、布林這三個型別在進行比較時，會轉型成「數值」型別，再進行比較。</u></strong></p><h3 id="Null、Undefined-型別的寬鬆比較規則"><a href="#Null、Undefined-型別的寬鬆比較規則" class="headerlink" title="Null、Undefined 型別的寬鬆比較規則"></a><span style="color:white; background-color: #2a2936; padding: 5px">Null、Undefined 型別的寬鬆比較規則</span></h3><p>null 及 undefined 時常會與 false 搞混，但在寬鬆比較時，它們幾乎是不會轉型，<br>就以下範例來說，無論是與數值 0、與空字串、布林值 false，進行比較的時候，最終所獲得的結果都是 false。</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-number">0</span>);           <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-string">&#x27;&#x27;</span>);          <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">false</span>);       <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-number">0</span>);      <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&#x27;&#x27;</span>);     <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">false</span>);  <span class="hljs-comment">// false</span></code></pre><p>有什麼口訣或技巧可以記嗎？<br><strong>當 null 與 undefined 只有在這兩者互相比較的時候結果為 true，其餘均為 false！！！</strong></p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span>);            <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// true</span></code></pre><h3 id="物件與非物件的寬鬆比較規則"><a href="#物件與非物件的寬鬆比較規則" class="headerlink" title="物件與非物件的寬鬆比較規則"></a><span style="color:white; background-color: #2a2936; padding: 5px">物件與非物件的寬鬆比較規則</span></h3><p>當物件與物件進行寬鬆比較時，會以「記憶體位址」來進行比較，所以得到的結果皆為 false。<br>不過當物件與其他原始型別進行寬鬆比較時，會產生不同的結果，這邊有一個很重要的概念是：「物件型別與其他型別進行比較時，會透過<u>包裹物件</u>將物件轉換成相同的型別後再進行比較」。</p><p>雖然都是提及物件，但是待會會用陣列當作範例。</p><ol><li><strong>陣列與數值型別進行比較</strong><br>當數值 10 與陣列 [10] 進行比較時，因為陣列屬於物件型別，因此會透過數值的 Number 包裹物件進行轉換，Number([10]) &#x3D; 10，轉換後的結果一樣為 10，所以比對結果為 true。</li></ol><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">10</span>] == <span class="hljs-number">10</span>);    <span class="hljs-comment">// true</span></code></pre><ol start="2"><li><strong>陣列與字串型別進行比較</strong><br>當陣列遇到字串型別時，會透過 String 包裹物件進行轉換，因此 [‘A’] 會轉為 ‘A’、[‘a’,’b’] 會轉為 ‘a,b’</li></ol><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-string">&#x27;A&#x27;</span>] == <span class="hljs-string">&#x27;A&#x27;</span>);    <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>] == <span class="hljs-string">&#x27;a,b&#x27;</span>);    <span class="hljs-comment">// true</span></code></pre><ol start="3"><li><strong>例外狀況：陣列與布林型別進行比較</strong><br>當布林值與陣列進行比較時，布林值會被 Number 包裹物件轉型成數值 1，<br>以及任何物件透過 Boolean 包裹物件進行轉型，都會得到 true 的結果。</li></ol><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>([]));                <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(&#123;&#125;));                <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;));    <span class="hljs-comment">// true</span></code></pre><p>下面的比對會得到 false，</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] == <span class="hljs-literal">true</span>);                <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == <span class="hljs-literal">true</span>);                <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125; == <span class="hljs-literal">true</span>);    <span class="hljs-comment">// false</span></code></pre><p>這是因為 true 被轉型了，當布林值與陣列進行比較時，布林值會被 Number 包裹物件轉型成數值 1！<br>所以只有 [1] 才會得到 true，其他都會得到 false</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>] == <span class="hljs-literal">true</span>);             <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">2</span>] == <span class="hljs-literal">true</span>);             <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">3</span>] == <span class="hljs-literal">true</span>);             <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == <span class="hljs-literal">true</span>);              <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125; == <span class="hljs-literal">true</span>);  <span class="hljs-comment">// false</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 型別 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 型別 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>型別 2：原始型別的包裹物件 Primitive Wrapper Objects</title>
      <link href="/2024/07/20/%E5%9E%8B%E5%88%A5-2%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5%E5%8C%85%E8%A3%B9%E7%89%A9%E4%BB%B6/"/>
      <url>/2024/07/20/%E5%9E%8B%E5%88%A5-2%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5%E5%8C%85%E8%A3%B9%E7%89%A9%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>注意文章的標題是「原始型別的包裹物件」，<br>因此接下來講的內容，都跟「原始型別」有關，但是與 <code>null</code>，<code>undefined</code> 無關。( 因為它們兩個沒有包裹物件 )</p><h2 id="為什麼原始型別的值可以呼叫方法？"><a href="#為什麼原始型別的值可以呼叫方法？" class="headerlink" title="為什麼原始型別的值可以呼叫方法？"></a>為什麼原始型別的值可以呼叫方法？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>因為 JavaScript 會自動將原始型別的值，轉換成對應的「包裹物件」後，再呼叫物件中的方法。</p></blockquote><p>在探討包裹物件之前，可以先思考一個問題，<br>為什麼當你宣告一個 string 變數時，可以使用如下<code>toUpperCase()</code>的方法?</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;John&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// &quot;JOHN&quot;</span></code></pre><p><code>name</code> 明明是一個原始型別的變數，為什麼可以像物件呼叫方法的方式去呼叫 <code>toUpperCase()</code>？</p><p>這是因為當你嘗試在一個原始值上呼叫方法時，JavaScript 會自動將<code>name</code>變數轉換成對應的「包裹物件」，而這個過程稱為「裝箱」（boxing）。<br>裝箱的工作原理如下：</p><ol><li><strong>創建臨時物件</strong>：JavaScript 會創建一個臨時的包裹物件( 以上面的例子來說，會創建一個「字串包裹物件」 )，這個過程是隱式的。</li><li><strong>呼叫對應方法</strong>：創建臨時包裹物件後，JavaScript 會在這個臨時物件上呼叫對應的方法( 以上面的例子來說是 <code>toUpperCase()</code> 方法)。</li><li><strong>回傳結果</strong>：方法執行完畢後，回傳結果。</li><li><strong>銷毀臨時物件</strong>：立即銷毀這個臨時創建的包裹物件，不會影響原始值。</li></ol><h2 id="將包裹物件視覺化會長怎樣？"><a href="#將包裹物件視覺化會長怎樣？" class="headerlink" title="將包裹物件視覺化會長怎樣？"></a>將包裹物件視覺化會長怎樣？</h2><p>既然知道「原始值」在呼叫方法時，JS 會自動轉換成對應的「包裹物件」再去呼叫該方法，<br>也知道轉換的過程是隱式的，那如果用顯式的方式來觀察轉換的過程，看起來會像下面的這樣：</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;John&quot;</span>;<span class="hljs-keyword">let</span> newName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(name);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newName.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// &quot;JOHN&quot;</span><span class="hljs-comment">// 然後銷毀 newName</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// &quot;John&quot; (原本的 name 值不受影響)</span></code></pre><p>解釋：</p><ul><li>宣告一個 type 為字串的 name 變數</li><li>透過 new 運算子搭配字串的「包裹物件函式 String」將 name 轉換成「包裹物件」(實戰上不推薦這樣使用)</li><li>在「包裹物件」上呼叫 toUpperCase() 方法，並回傳結果</li></ul><h3 id="包裹物件與原始值的區別"><a href="#包裹物件與原始值的區別" class="headerlink" title="包裹物件與原始值的區別"></a>包裹物件與原始值的區別</h3><p>最大的區別當然是 type 啦</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;John&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> name); <span class="hljs-comment">// &quot;string&quot;</span><span class="hljs-keyword">let</span> newName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(name);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> newName); <span class="hljs-comment">// &quot;object&quot;</span></code></pre><h3 id="哪些原始值可以使用包裹物件函式"><a href="#哪些原始值可以使用包裹物件函式" class="headerlink" title="哪些原始值可以使用包裹物件函式"></a>哪些原始值可以使用包裹物件函式</h3><table><thead><tr><th>型別</th><th>包裹物件</th><th>使否可作為函式建構子使用</th></tr></thead><tbody><tr><td>字串 (String)</td><td>有包裹物件：String</td><td>是</td></tr><tr><td>數值 (Number)</td><td>有包裹物件：Number</td><td>是</td></tr><tr><td>布林 (Boolean)</td><td>有包裹物件：Boolean</td><td>是</td></tr><tr><td>BigInt</td><td>有包裹物件：BigInt</td><td>否</td></tr><tr><td>Symbol</td><td>有包裹物件：Symbol</td><td>否</td></tr><tr><td>undefined</td><td>無包裹物件</td><td>無</td></tr><tr><td>null</td><td>無包裹物件</td><td>無</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 型別 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 型別 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>型別 1：原始型別 &amp; 物件型別</title>
      <link href="/2024/07/14/%E5%9E%8B%E5%88%A5-1%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5/"/>
      <url>/2024/07/14/%E5%9E%8B%E5%88%A5-1%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-的型別"><a href="#JavaScript-的型別" class="headerlink" title="JavaScript 的型別"></a>JavaScript 的型別</h2><p>在 JavaScript 的世界裡，只有兩大型別，分別是 <strong>Primitive Type（原始型別）</strong>和 <strong>Object Type（物件型別）</strong>。</p><h4 id="原始型別的種類如下："><a href="#原始型別的種類如下：" class="headerlink" title="原始型別的種類如下："></a>原始型別的種類如下：</h4><ul><li>Boolean</li><li>Number</li><li>String</li><li>BigInt</li><li>Symbol</li><li>Null</li><li>Undefined</li></ul><h4 id="以下種類皆為物件型別："><a href="#以下種類皆為物件型別：" class="headerlink" title="以下種類皆為物件型別："></a>以下種類皆為物件型別：</h4><ul><li>Array</li><li>Object</li><li>Function</li></ul><p>除了原始型別以外，其餘都可以歸類在物件型別，例如陣列、物件、函式都屬於物件型別。</p><blockquote><p>JavaScript 共有 7 種 <strong>「原始型別</strong>，其餘的都屬於 <strong>「物件型別」</strong>。</p></blockquote><h2 id="如何區分原始型別與物件型別？"><a href="#如何區分原始型別與物件型別？" class="headerlink" title="如何區分原始型別與物件型別？"></a>如何區分原始型別與物件型別？</h2><h3 id="原始型別無法增加屬性，物件型別可以增加屬性"><a href="#原始型別無法增加屬性，物件型別可以增加屬性" class="headerlink" title="原始型別無法增加屬性，物件型別可以增加屬性"></a>原始型別無法增加屬性，物件型別可以增加屬性</h3><p>原始型別：</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> string = <span class="hljs-string">&quot;我是小明&quot;</span>;string.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;我是字串&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-property">name</span>); <span class="hljs-comment">// undefined，無法新增屬性</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string); <span class="hljs-comment">// 我是小明</span></code></pre><p>物件型別：</p><pre><code class="hljs JS"><span class="hljs-comment">// 對物件新增屬性</span><span class="hljs-keyword">let</span> object = &#123;  <span class="hljs-attr">property</span>: <span class="hljs-string">&quot;我是物件&quot;</span>,&#125;object.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;我是一個屬性&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;我是一個屬性&quot;</span><span class="hljs-comment">// 對陣列新增屬性（實戰中請不要對陣列這樣做)</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];arr.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;我是一個陣列&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;我是一個陣列&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<span class="hljs-comment">// [1, 2, 3, name: &#x27;我是一個陣列&#x27;]</span><span class="hljs-comment">// 對函式新增屬性（實戰中請不要對函式這樣做)</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;&#125;fn.<span class="hljs-property">myName</span> = <span class="hljs-string">&quot;我是一個函式&quot;</span>; <span class="hljs-comment">// 函式本身就有 name 屬性，別覆蓋它</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-property">myName</span>); <span class="hljs-comment">// &quot;我是一個函式&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(fn); <span class="hljs-comment">// 可以印出函式的結構</span></code></pre><h3 id="型別判斷方式"><a href="#型別判斷方式" class="headerlink" title="型別判斷方式"></a>型別判斷方式</h3><p>在大多數型別中，都可以透過 <code>typeof</code> 運算子來判別，是實戰中最常見用來判斷型別的手法，例如下方的一些例子：</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;這是一句話&quot;</span>); <span class="hljs-comment">// &quot;string&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>); <span class="hljs-comment">// &quot;number&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>); <span class="hljs-comment">// &quot;boolean&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;sym&quot;</span>)); <span class="hljs-comment">// &quot;symbol&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">100n</span>); <span class="hljs-comment">// &quot;bigint&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;object&quot;，null 會被判斷成 Object 型別，這是一個 JS 的 Bug，然後官方也不打算改( 因為會牽一髮動全身 )</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// &quot;undefined&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> []); <span class="hljs-comment">// &quot;object&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;); <span class="hljs-comment">// &quot;object&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;); <span class="hljs-comment">// &quot;function&quot;，雖然印出 function，但還是當作物件型別看待</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 型別 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 型別 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 6：undefined 與 null 的差異</title>
      <link href="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-6%EF%BC%9Aundefined-%E8%88%87-null-%E7%9A%84%E5%B7%AE%E7%95%B0-1/"/>
      <url>/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-6%EF%BC%9Aundefined-%E8%88%87-null-%E7%9A%84%E5%B7%AE%E7%95%B0-1/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在 Javascript 中有兩大型別，其中 <font color=#0000FF>undefined</font> 與 <font color=#0000FF>null</font> 都是屬於 <font color=#FF0000>Primitive value</font>( 原始值或稱基本型別 )，<br>而<strong>原始值是無法被更改的！</strong>，<br>例如 Boolean 只會有 true 和 false 這兩種值，因此 null 、undefined 也是一樣。<br>undefined 型別只有一種值，就是 <font color=#0000FF>undefined</font>。<br>null 型別只有一種值，就是 <font color=#0000FF>null</font>。</p><h3 id="undefined-的定義"><a href="#undefined-的定義" class="headerlink" title="undefined 的定義"></a>undefined 的定義</h3><p><font color=#0000FF>undefined</font> 表示一個變數已經被宣告，但是該變數的值尚未定義。<br>『undefined means a variable has been declared but has not yet been assigned a value 。』<br>例：</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> test;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test); <span class="hljs-comment">//shows undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> test); <span class="hljs-comment">//shows undefined</span></code></pre><h3 id="null-的定義"><a href="#null-的定義" class="headerlink" title="null 的定義"></a>null 的定義</h3><p><font color=#0000FF>null</font> 是一個值，可以被賦予到一個變數上，來表示該變數目前的值是空值。<br>『null is an assignment value. It can be assigned to a variable as a representation of no value』</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> test = <span class="hljs-literal">null</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test); <span class="hljs-comment">//shows undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> test); <span class="hljs-comment">//shows object</span><span class="hljs-comment">/*</span><span class="hljs-comment">  注意：</span><span class="hljs-comment">  變數目前的值是空值不等於變數目前的值為 0，</span><span class="hljs-comment">  空值 ≠ 0。</span><span class="hljs-comment">*/</span></code></pre><h3 id="從定義了解差異"><a href="#從定義了解差異" class="headerlink" title="從定義了解差異"></a>從定義了解差異</h3><p>從前面兩個程式碼的例子中可以發現，<font color=#0000FF>undefined</font> 和 <font color=#0000FF>null</font> 是兩種不同的型別</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false (not the same type)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true (but the &quot;same value&quot;)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> === <span class="hljs-literal">null</span>) <span class="hljs-comment">// true (both type and value are the same)</span></code></pre><table><thead><tr><th></th><th>undefined</th><th>null</th></tr></thead><tbody><tr><td>定義</td><td>表示某變數已經被宣告，但該變數的值<font color=#FF0000>尚未定義</font></td><td>變數的值<font color=#FF0000>已經定義</font>，值是 null，表示變數目前的值是空值</td></tr></tbody></table><h2 id="使用情境來理解差異"><a href="#使用情境來理解差異" class="headerlink" title="使用情境來理解差異"></a>使用情境來理解差異</h2><ul><li><strong><font color=#ffa500>name is undefined</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// name is undefined</span><span class="hljs-keyword">var</span> name;</code></pre><p>You: What is name?<br>JavaScript: name? What’s a name? I don’t know what you’re talking about. You haven’t ever mentioned any name before. Are you seeing some other scripting language on the client-side?</p><ul><li><strong><font color=#ffa500>name &#x3D; null</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-literal">null</span>;</code></pre><p>You: What is name?<br>JavaScript: I don’t</p><ul><li><strong><font color=#ffa500>name &#x3D; false</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-literal">false</span>;</code></pre><p>You: What is name?<br>JavaScript: Boolean false.</p><ul><li><strong><font color=#ffa500>name &#x3D; “”</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;&quot;</span>;</code></pre><p>You: What is name?<br>JavaScript: Empty string.</p><h2 id="一張圖理解差異"><a href="#一張圖理解差異" class="headerlink" title="一張圖理解差異"></a>一張圖理解差異</h2><p><img src="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-6%EF%BC%9Aundefined-%E8%88%87-null-%E7%9A%84%E5%B7%AE%E7%95%B0-1/image.png"></p><h2 id="undefined-可以當作變數名稱或參數使用"><a href="#undefined-可以當作變數名稱或參數使用" class="headerlink" title="undefined 可以當作變數名稱或參數使用"></a>undefined 可以當作變數名稱或參數使用</h2><p>驚不驚喜，意不意外～我們常說不能拿保留字當作變數，沒想到 undefined 居然打破這個限制！！！在非全域作用範圍下， undefined 允許被當成變數名稱，而且變數的值是可以被修改的。</p><pre><code class="hljs JS"><span class="hljs-comment">// 當作變數名稱</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`值為<span class="hljs-subst">$&#123;<span class="hljs-literal">undefined</span>&#125;</span>，型別為<span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>&#125;</span>`</span>); <span class="hljs-comment">// 顯示：值為foo，型別為string</span>&#125;)()<span class="hljs-comment">// 當作參數</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-literal">undefined</span></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`值為<span class="hljs-subst">$&#123;<span class="hljs-literal">undefined</span>&#125;</span>，型別為<span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>&#125;</span>`</span>); <span class="hljs-comment">// 顯示：值為foo，型別為string</span>&#125;)(<span class="hljs-string">&#x27;foo&#x27;</span>);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 5：undefined &amp; is not defined</title>
      <link href="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-5%EF%BC%9Aundefined-is-not-defined/"/>
      <url>/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-5%EF%BC%9Aundefined-is-not-defined/</url>
      
        <content type="html"><![CDATA[<h2 id="undefined-is-not-defined-兩者之間的差別？"><a href="#undefined-is-not-defined-兩者之間的差別？" class="headerlink" title="undefined &amp; is not defined 兩者之間的差別？"></a>undefined &amp; is not defined 兩者之間的差別？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>undefined 是一個變數尚未被賦予值的狀態。<br>「is not defined」是一個<font color=#FF0000>錯誤</font>訊息，會直接中斷程式碼執行。</p></blockquote><ul><li>is not defined 的例子</li></ul><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// Uncaught ReferenceError: myName is not defined</span></code></pre><ul><li>undefined 的例子</li></ul><pre><code class="hljs JS"><span class="hljs-number">1.</span>  <span class="hljs-keyword">var</span> myName;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-number">2.</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);  <span class="hljs-keyword">var</span> myName;<span class="hljs-number">3.</span>  <span class="hljs-keyword">var</span> person = &#123;&#125;;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// 印出物件中沒有的屬性也會顯示 undefined (避免程式直接中斷，算是一種保護機制)</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>.<span class="hljs-property">first</span>) <span class="hljs-comment">// 但是若想取得更深層的屬性，就會跳出下面的錯誤，</span>   <span class="hljs-comment">// Uncaught TypeError: Cannot read properties of undefined (reading &#x27;first&#x27;)</span>  <span class="hljs-comment">/*</span><span class="hljs-comment">  以下兩個例子可以檢視欲存取的屬性值在不在</span><span class="hljs-comment">  1.</span><span class="hljs-comment">    if(person.hasOwnProperty(&#x27;name&#x27;))&#123; // 如果有 name 這個屬性</span><span class="hljs-comment">    console.log(person.name.first);  // 才針對更深層的屬性取值</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">  2.</span><span class="hljs-comment">    console.log(person?.name?.first); // 可選串連，會取得 undefined 的結果，不會出錯</span><span class="hljs-comment">  */</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 4：TDZ</title>
      <link href="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%204%EF%BC%9ATDZ/"/>
      <url>/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%204%EF%BC%9ATDZ/</url>
      
        <content type="html"><![CDATA[<h2 id="什麼是-TDZ（Temporal-dead-zone）？"><a href="#什麼是-TDZ（Temporal-dead-zone）？" class="headerlink" title="什麼是 TDZ（Temporal dead zone）？"></a>什麼是 TDZ（Temporal dead zone）？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>意指 let 、const 宣告變數的「前方區域」，如果試圖在此區域取得值，則會出現 ReferenceError 的提示。</p></blockquote><p>在傳統的 var 宣告中，若是先取值再宣告並不會出錯，會出現「Undefined」。<br>但是在 let、const 宣告的情況下，先取值再宣告的話，會出現「Uncaught ReferenceError：Cannot access ‘xxx’ before initialization」(依瀏覽器版本可能出現不同訊息)，<br>也就是說 let、const 無法在初始化之前就取得該變數，因此開發者會很清楚不該這麼做~</p><blockquote><p>let、const 一樣有「提升」的概念，只是沒辦法存取裡面的值而已！<br>而 var 是出現「undefined」，可以存到值，只是值是 undefined。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 3：提升(Hoisting)</title>
      <link href="/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%203%EF%BC%9A%E6%8F%90%E5%8D%87(Hoisting)/"/>
      <url>/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%203%EF%BC%9A%E6%8F%90%E5%8D%87(Hoisting)/</url>
      
        <content type="html"><![CDATA[<h2 id="什麼是提升（Hoisting）？"><a href="#什麼是提升（Hoisting）？" class="headerlink" title="什麼是提升（Hoisting）？"></a>什麼是提升（Hoisting）？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>在 JavaScript 中先賦予變數或函式一個記憶體空間的這個機制，就稱為<strong>提升</strong>。</p></blockquote><h3 id="在這之前先來談創造階段與執行階段這兩個概念"><a href="#在這之前先來談創造階段與執行階段這兩個概念" class="headerlink" title="在這之前先來談創造階段與執行階段這兩個概念"></a>在這之前先來談創造階段與執行階段這兩個概念</h3><ul><li>創造階段（Creation）：瀏覽器為變數或是函式創造記憶體空間的階段。</li><li>執行階段（Execution）：瀏覽器將「值」賦予變數的階段。</li></ul><ol><li>先以下列程式碼為例子</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">//印出小白</span><span class="hljs-comment">/*</span><span class="hljs-comment">    解釋上述程式碼的 創造階段 與 執行階段</span><span class="hljs-comment">    1. 創造階段：myName 變數「提升」，獲得一個記憶體空間，其值是 undefined</span><span class="hljs-comment">    2. 執行階段：myName 變數被賦予值，其值是&#x27;小白&#x27;，console.log(myName) 會將 myName 變數中的值取出來後印出來</span><span class="hljs-comment">*/</span></code></pre><ol start="2"><li>修改一下順序</li></ol><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">// console.log 會印出 undefined，而不是 Uncaught ReferenceError: myName is not defined 的錯誤。</span><span class="hljs-comment">/*</span><span class="hljs-comment">  為什麼不會印出錯誤？myName 變數不是後面才宣告嗎？原因是因為 myName 變數「提升」了！</span><span class="hljs-comment">  在印出來之前，myName 變數已經有了記憶體空間，只是還沒被賦予值，因此是 undefined。</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">  1. 創造階段：myName 變數「提升」，獲得一個記憶體空間，其值是 undefined</span><span class="hljs-comment">  2. 執行階段：console.log(myName) 將 myName 變數中的值印出來 ( 先印出 undefined )</span><span class="hljs-comment">              然後 myName 變數才被賦予 &#x27;小白&#x27; 這個值。</span><span class="hljs-comment">*/</span></code></pre><blockquote><p>有了提升的概念之後，在來要討論的是，函式提升與變數提升的不同處。</p></blockquote><h2 id="函式的創造階段與執行階段，與變數相比多了兩個原則："><a href="#函式的創造階段與執行階段，與變數相比多了兩個原則：" class="headerlink" title="函式的創造階段與執行階段，與變數相比多了兩個原則："></a>函式的創造階段與執行階段，與變數相比多了兩個原則：</h2><ul><li>函式在創造階段就已經有完整的記憶體空間</li><li><strong>函式陳述式</strong>優先函式表達式與變數宣告</li></ul><ol><li>舉例</li></ol><pre><code class="hljs JS"><span class="hljs-title function_">callName</span>();<span class="hljs-comment">/*</span><span class="hljs-comment">  callName 函式在比較下面，理論上應該是沒辦法成功執行 callName()，</span><span class="hljs-comment">  但是因為「提升」的機制，使得 callName 函式優先獲得記憶體空間，因此你要在哪裡呼叫都可以</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 下行函式的宣告方式叫做「函式陳述式」</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">callName</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是小明&#x27;</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    解釋上述程式碼的創造階段與執行階段</span><span class="hljs-comment">    1. 創造階段：callName 函式陳述式優先「提升」，獲得一個記憶體空間</span><span class="hljs-comment">    2. 執行階段：呼叫了 callName() 函式，印出&#x27;我是小明&#x27;</span><span class="hljs-comment">*/</span></code></pre><ol start="2"><li>函式陳述式 v.s 函式表達式 ⇒ 兩者之間的差異在於「提升的方式」不同</li></ol><pre><code class="hljs JS"><span class="hljs-comment">//函式陳述式</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;這是函式陳述式&#x27;</span>);&#125;<span class="hljs-comment">//函式表達式</span><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;這是函式表達式&#x27;</span>);&#125;<span class="hljs-title function_">fn</span>();<span class="hljs-comment">//呼叫 fn 函式，會印出 &#x27;這是函式陳述式&#x27; 還是 &#x27;這是函式表達式呢&#x27;？</span><span class="hljs-comment">/*</span><span class="hljs-comment">    這邊開始解釋「函式陳述式」與「函式表達式」的不同處，</span><span class="hljs-comment">    以上述程式碼為例，列出創造階段與執行階段</span><span class="hljs-comment"></span><span class="hljs-comment">    1. 創造階段：</span><span class="hljs-comment">        function fn()&#123; //函式陳述式優先提升</span><span class="hljs-comment">          console.log(&#x27;這是函式陳述式&#x27;);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        var fn; //fn 變數提升</span><span class="hljs-comment"></span><span class="hljs-comment">    2. 執行階段：</span><span class="hljs-comment">        fn = function()&#123; // fn 被賦予值</span><span class="hljs-comment">          console.log(&#x27;這是函式表達式&#x27;);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        fn(); //呼叫 fn 函式，最終印出&#x27;這是函式表達式&#x27;！！</span><span class="hljs-comment"></span><span class="hljs-comment">    不同之處在於函式表達式會在執行階段才將值(整個function) assign 給 fn 變數，</span><span class="hljs-comment">    進而覆蓋了在創造階段出現的函式陳述式，所以才會印出&#x27;函式表達式&#x27;。</span><span class="hljs-comment">*/</span></code></pre><p>第一次理解 Hoisting 時有點小吃力，<br>不過大腦是一個神奇的東西，隨著時間拉長再回頭看，就知道這是什麼了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 2：變數作用域的範圍</title>
      <link href="/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%202%EF%BC%9A%E8%AE%8A%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%AF%84%E5%9C%8D/"/>
      <url>/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%202%EF%BC%9A%E8%AE%8A%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%AF%84%E5%9C%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="var、let、const-三者宣告出來的變數作用域差別為何？"><a href="#var、let、const-三者宣告出來的變數作用域差別為何？" class="headerlink" title="var、let、const 三者宣告出來的變數作用域差別為何？"></a>var、let、const 三者宣告出來的變數作用域差別為何？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>var 的作用域範圍在函式內( 所以又稱函式作用域 )，let、const 則屬於區塊作用域，且目前主流的宣告方式皆採用 let、const。</p></blockquote><p>等等，什麼是函式作用域？什麼是區塊作用域？</p><h3 id="函式作用域"><a href="#函式作用域" class="headerlink" title="函式作用域"></a>函式作用域</h3><p>函式作用域的意思就是，變數的生命週期在一個函式內，然後樣子看來起來像這樣：</p><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;    <span class="hljs-comment">// myName 的生命週期僅存在此函式中</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);&#125;<span class="hljs-title function_">fn</span>();<span class="hljs-comment">//印出小白</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// Uncaught ReferenceError: myName is not defined</span></code></pre><h3 id="區塊作用域"><a href="#區塊作用域" class="headerlink" title="區塊作用域"></a>區塊作用域</h3><p>區塊作用域則有下列幾種類型</p><ul><li>函式：function fn() { …… } 區塊作用域是函式作用域的一種</li><li>for 迴圈：for( xxx）{ …… }</li><li>判斷式：if( expression ){ …… }</li><li>純粹的區塊：｛｝</li><li>基本上看到｛｝都可以認定為一個區塊</li></ul><h3 id="好像還看不太出來差別，用以下例子區分"><a href="#好像還看不太出來差別，用以下例子區分" class="headerlink" title="好像還看不太出來差別，用以下例子區分"></a>好像還看不太出來差別，用以下例子區分</h3><ul><li>for 迴圈</li></ul><pre><code class="hljs JS"><span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span>; i++ )&#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<span class="hljs-comment">// 印出 10，抓得到 i 這個值！！</span><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span> ; j&lt;<span class="hljs-number">10</span>; j++ )&#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<span class="hljs-comment">// 印出 Uncaught ReferenceError: j is not defined</span></code></pre><ul><li>for 迴圈</li></ul><pre><code class="hljs JS"><span class="hljs-keyword">if</span>( ..... )&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// 印出小白</span><span class="hljs-keyword">if</span>( ..... )&#123;    <span class="hljs-keyword">let</span> yourName = <span class="hljs-string">&#x27;小葵&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(yourName);<span class="hljs-comment">// 印出 Uncaught ReferenceError: yourName is not defined</span></code></pre><ul><li>純粹的區塊</li></ul><pre><code class="hljs JS">&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// 印出小白</span>&#123;    <span class="hljs-keyword">let</span> yourName = <span class="hljs-string">&#x27;小葵&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(yourName);<span class="hljs-comment">// 印出 Uncaught ReferenceError: yourName is not defined</span></code></pre><p>從上述三個例子中可以發現，<br>區塊作用域的優點會比函式作用域的優點要來得多，<br>因為 var 所宣告的變數，除了在函式中宣告的不會變成全域變數外，其餘都會變成全域變數，<br>這在幾百行幾千行中是非常難以除錯的，因此 let、const 宣告詞才會成為主流。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 1：全域變數 &amp; 全域屬性</title>
      <link href="/2024/07/12/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%201%EF%BC%9A%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8%20&amp;%20%E5%85%A8%E5%9F%9F%E5%B1%AC%E6%80%A7/"/>
      <url>/2024/07/12/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%201%EF%BC%9A%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8%20&amp;%20%E5%85%A8%E5%9F%9F%E5%B1%AC%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="為什麼變數需要宣告？能不宣告直接用嗎？"><a href="#為什麼變數需要宣告？能不宣告直接用嗎？" class="headerlink" title="為什麼變數需要宣告？能不宣告直接用嗎？"></a>為什麼變數需要宣告？能不宣告直接用嗎？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>沒有透過「宣告」產生出來的變數，會是一個「全域的 windows 物件底下的一個屬性」。</p></blockquote><p>變數如果不透過 var、let 、const 宣告的話，會變成一個名為 windwos 物件底下的一個屬性，<br>該屬性是一個全域屬性！<br>範例：</p><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">// 注意，a 變數並沒有透過 var、let、const 來宣告，</span>    <span class="hljs-comment">// 卻可以被底下的 fn2() 所使用</span>    a = <span class="hljs-string">&#x27;小明&#x27;</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>)<span class="hljs-comment">// 實際上這個 a 變數是 winsows 物件下的一個屬性</span>&#125;<span class="hljs-title function_">fn1</span>(); <span class="hljs-comment">// 呼叫 fn1()，產生一個具全域屬性 a</span><span class="hljs-title function_">fn2</span>(); <span class="hljs-comment">// 呼叫 fn2()，印出兩次小明</span></code></pre><p>這種沒有透過「宣告」的方式所產生出來的變數，會因為是一個全域屬性的關係，容易被汙染，進而難以 debug。</p><h2 id="那變數與屬性的差異為何？"><a href="#那變數與屬性的差異為何？" class="headerlink" title="那變數與屬性的差異為何？"></a>那變數與屬性的差異為何？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>差異就是只有「屬性」才可以使用 delete 運算子刪除 。</p></blockquote><p>範例：</p><pre><code class="hljs JS">a = <span class="hljs-string">&#x27;小白&#x27;</span>; <span class="hljs-comment">//因為沒有用宣告字，所以會在 windows 物件底下會新增一個屬性叫做 a</span><span class="hljs-keyword">delete</span> a; <span class="hljs-comment">// a 是一個全域屬性，可透過 delete 刪除</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>); <span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span></code></pre><pre><code class="hljs JS"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;小白&#x27;</span>; <span class="hljs-comment">// 雖然是用「宣告的方式」，但 windows 物件底下還是會新增一個屬性叫做 a，</span>                <span class="hljs-comment">// 但透過「宣告的方式」所產生出來的屬性是無法利用 delete 運算子刪除的</span><span class="hljs-keyword">delete</span> a; <span class="hljs-comment">// 無法透過 delete 刪除</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>); <span class="hljs-comment">//印出小白</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 印出小白</span></code></pre><p>沒使用宣告字宣告的變數 -&gt; 全域屬性，可用 delete 運算子刪除此屬性。<br>使用 var 宣告字宣告的變數 -&gt; 全域變數，無法使用 delete 運算子刪除。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/07/12/hello-world/"/>
      <url>/2024/07/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
