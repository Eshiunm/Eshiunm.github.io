<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C# 中的 static</title>
      <link href="/2024/08/07/C-%E4%B8%AD%E7%9A%84-static/"/>
      <url>/2024/08/07/C-%E4%B8%AD%E7%9A%84-static/</url>
      
        <content type="html"><![CDATA[<h1 id="一些-static-的觀念-尚未整理的筆記"><a href="#一些-static-的觀念-尚未整理的筆記" class="headerlink" title="一些 static 的觀念(尚未整理的筆記)"></a>一些 static 的觀念(尚未整理的筆記)</h1><h2 id="static-怎麼用？"><a href="#static-怎麼用？" class="headerlink" title="static 怎麼用？"></a>static 怎麼用？</h2><p><code>static</code> 是一個 C# 中的修飾字，主要用在「類別」上，但是是用在類別的哪裡？<br>可以用在類別本身，也可以用在類別中的成員。</p><h2 id="當-static-用在類別身上時"><a href="#當-static-用在類別身上時" class="headerlink" title="當 static 用在類別身上時"></a>當 static 用在類別身上時</h2><p>當一個類別在 C# 中被宣告為靜態類別時，有一些特性和限制：</p><ol><li>無法實例化：靜態類別不能被實例化，這意味著不能使用 <code>new</code> 關鍵字創建該類別的物件。</li><li>成員只能是靜態成員：靜態類別只能包含靜態成員，如靜態方法、靜態屬性，不能包含非靜態成員。</li><li>本身有密封性（Sealed）：這意味著不能被繼承。</li><li>不能有非靜態建構函式：但可以有靜態建構函式。</li><li>不能實作介面：由於靜態類別不能被實例化，所以它不能實作任何介面。</li><li>直接透過類別名稱存取：靜態類別的成員可以直接透過類別名稱來存取，不需要實例化。</li><li>生命週期：靜態類別的成員在應用程式域的整個生命週期內都存活。</li></ol><p>以下是一個靜態類別的例子：</p><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathUtilities</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">double</span> PI = <span class="hljs-number">3.14159</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">CalculateCircleArea</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span>    &#123;        <span class="hljs-keyword">return</span> PI * radius * radius;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>    &#123;        <span class="hljs-keyword">return</span> a + b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">MathUtilities</span>()</span>    &#123;        <span class="hljs-comment">// 靜態建構函式，在類別第一次被使用時會執行</span>        Console.WriteLine(<span class="hljs-string">&quot;MathUtilities initialized&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;      <span class="hljs-comment">// 使用靜態類別，不用 new 出來，直接使用</span>      <span class="hljs-built_in">double</span> area = MathUtilities.CalculateCircleArea(<span class="hljs-number">5</span>);      <span class="hljs-built_in">int</span> sum = MathUtilities.Add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);      Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;area&#125;</span>&quot;</span>);      Console.WriteLine(<span class="hljs-string">$&quot;Sum: <span class="hljs-subst">&#123;sum&#125;</span>&quot;</span>);    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">  輸出結果：</span><span class="hljs-comment">  MathUtilities initialized</span><span class="hljs-comment">  Circle Area: 78.53975</span><span class="hljs-comment">  Sum: 7</span><span class="hljs-comment">*/</span></code></pre><h2 id="當-static-用在類別中的成員時"><a href="#當-static-用在類別中的成員時" class="headerlink" title="當 static 用在類別中的成員時"></a>當 static 用在類別中的成員時</h2><p>當一個非靜態類別中包含靜態成員時，有一些特別的情況要考慮：</p><ol><li>類別中含有靜態成員跟非靜態成員：<br>靜態成員屬於類別本身，而非靜態成員則屬於實例化後的物件。</li><li>靜態成員的存取：<br>靜態成員可以直接通過類別名稱存取，不需要創建類別的實例。<br>非靜態成員則需要實例化後才可以存取。</li><li>記憶體管理：<br>靜態成員在應用程式啟動時就會被分配到記憶體，並在整個應用程式生命週期中存在。<br>非靜態成員只有在實例化後，成為物件時才分配記憶體，並隨著物件被銷毀而釋放。</li><li>靜態成員會被共享：<br>靜態成員會在所有實例化後的物件之間被共享，可以用來存儲或處理需要共用的數據。</li><li>初始化順序：<br>靜態成員在類別第一次被使用時就會初始化。<br>如果類別有靜態構造函數(建構子)，它會在任何靜態成員被存取之前，或任何實例被創造之前執行。</li><li>在實例中可以被存取：<br>非靜態方法可以直接存取靜態成員，但靜態方法不能直接存取非靜態成員。</li></ol><p>以下是一個靜態成員的例子：</p><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span>&#123;    <span class="hljs-comment">// 靜態成員</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> totalCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> TotalInstances =&gt; totalCount;    <span class="hljs-comment">// 實例成員</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 靜態構造函數</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Counter</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">&quot;Static constructor called&quot;</span>);    &#125;    <span class="hljs-comment">// 實例構造函數</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>()</span>    &#123;        ID = ++totalCount;        Console.WriteLine(<span class="hljs-string">$&quot;Instance <span class="hljs-subst">&#123;ID&#125;</span> created&quot;</span>);    &#125;    <span class="hljs-comment">// 靜態方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ResetCount</span>()</span>    &#123;        totalCount = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 實例方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayInfo</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;This is instance <span class="hljs-subst">&#123;ID&#125;</span> out of <span class="hljs-subst">&#123;totalCount&#125;</span> total instances&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        <span class="hljs-comment">// 靜態建構子會先被呼叫後，才執行靜態成員，這邊呼叫到的是「TotalInstances」這個靜態屬性</span>        Console.WriteLine(<span class="hljs-string">$&quot;Total instances before creating any: <span class="hljs-subst">&#123;Counter.TotalInstances&#125;</span>&quot;</span>);        Counter c1 = <span class="hljs-keyword">new</span> Counter();        Counter c2 = <span class="hljs-keyword">new</span> Counter();        c1.DisplayInfo();        c2.DisplayInfo();        Console.WriteLine(<span class="hljs-string">$&quot;Total instances: <span class="hljs-subst">&#123;Counter.TotalInstances&#125;</span>&quot;</span>);        Counter.ResetCount();        Console.WriteLine(<span class="hljs-string">$&quot;After reset, total instances: <span class="hljs-subst">&#123;Counter.TotalInstances&#125;</span>&quot;</span>);    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">  輸出結果：</span><span class="hljs-comment">  Static constructor called</span><span class="hljs-comment">  Total instances before creating any: 0</span><span class="hljs-comment">  Instance 1 created</span><span class="hljs-comment">  Instance 2 created</span><span class="hljs-comment">  This is instance 1 out of 2 total instances</span><span class="hljs-comment">  This is instance 2 out of 2 total instances</span><span class="hljs-comment">  Total instances: 2</span><span class="hljs-comment">  After reset, total instances: 0</span><span class="hljs-comment">*/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 後端 </category>
          
          <category> C# </category>
          
          <category> 型別 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些物件導向的題目</title>
      <link href="/2024/08/06/%E4%B8%80%E4%BA%9B%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%9A%84%E9%A1%8C%E7%9B%AE/"/>
      <url>/2024/08/06/%E4%B8%80%E4%BA%9B%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%9A%84%E9%A1%8C%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="1-物件導向程式設計的三大基本特性是什麼？"><a href="#1-物件導向程式設計的三大基本特性是什麼？" class="headerlink" title="1. 物件導向程式設計的三大基本特性是什麼？"></a>1. 物件導向程式設計的三大基本特性是什麼？</h3><ol><li>封裝 (Encapsulation)</li><li>繼承 (Inheritance)</li><li>多型 (Polymorphism)</li></ol><h3 id="2-定義函式多載（Function-Overload）並給出一個使用不同參數的方法多載例子"><a href="#2-定義函式多載（Function-Overload）並給出一個使用不同參數的方法多載例子" class="headerlink" title="2. 定義函式多載（Function Overload）並給出一個使用不同參數的方法多載例子"></a>2. 定義函式多載（Function Overload）並給出一個使用不同參數的方法多載例子</h3><p>函式多載是指在一個類別中，定義多個名稱相同但參數類型不同的函式。<br>這些函式可以有不同的參數類型、參數數量或參數順序。編譯器會根據呼叫時提供的參數來決定使用哪一個函式。</p><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span>&#123;    <span class="hljs-comment">// 兩個整數相加</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>    &#123;        <span class="hljs-keyword">return</span> a + b;    &#125;    <span class="hljs-comment">// 三個整數相加</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b, <span class="hljs-built_in">int</span> c</span>)</span>    &#123;        <span class="hljs-keyword">return</span> a + b + c;    &#125;    <span class="hljs-comment">// 兩個浮點數相加</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> a, <span class="hljs-built_in">double</span> b</span>)</span>    &#123;        <span class="hljs-keyword">return</span> a + b;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        Calculator calc = <span class="hljs-keyword">new</span> Calculator();        <span class="hljs-built_in">int</span> result1 = calc.Add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);           <span class="hljs-comment">// 呼叫 int Add(int a, int b)</span>        <span class="hljs-built_in">int</span> result2 = calc.Add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);        <span class="hljs-comment">// 呼叫 int Add(int a, int b, int c)</span>        <span class="hljs-built_in">double</span> result3 = calc.Add(<span class="hljs-number">2.5</span>, <span class="hljs-number">3.7</span>);    <span class="hljs-comment">// 呼叫 double Add(double a, double b)</span>    &#125;&#125;</code></pre><h3 id="3-建構函式在-C-中的用途是什麼？提供一個帶有參數的建構函式的例子"><a href="#3-建構函式在-C-中的用途是什麼？提供一個帶有參數的建構函式的例子" class="headerlink" title="3. 建構函式在 C# 中的用途是什麼？提供一個帶有參數的建構函式的例子"></a>3. 建構函式在 C# 中的用途是什麼？提供一個帶有參數的建構函式的例子</h3><p>建構函式(建構子)在 C#中的主要用途是:</p><ol><li>設定預設值: 當創建一個新的物件實例時，若沒有給與初始化的參數，則會自動將屬性套上預設值。</li><li>設定初始狀態: 當創建一個新的物件實例時，若有給與初始化的參數，則將這些參數賦予到新物件的屬性上。</li><li>準備空間: 建構函式可以替物件分配出必要的記憶體空間。</li><li>執行必要的設定: 負責所有物件「開始運作」前的準備工作，包括檢查某些條件是否滿足，、進行一些初始化的計算等等。</li></ol><p>以下是一個帶有參數的建構函式的例子:</p><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 帶有參數的建構函式</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span>    &#123;        Name = name;        Age = age;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        <span class="hljs-comment">// 使用建構函式創建 Person 物件</span>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;person.Name&#125;</span>, Age: <span class="hljs-subst">&#123;person.Age&#125;</span>&quot;</span>);    &#125;&#125;</code></pre><h3 id="4-提供一個例子，展示如何在-C-中覆寫父類別"><a href="#4-提供一個例子，展示如何在-C-中覆寫父類別" class="headerlink" title="4. 提供一個例子，展示如何在 C# 中覆寫父類別"></a>4. 提供一個例子，展示如何在 C# 中覆寫父類別</h3><p>這個例子將展示如何使用 <code>override</code> 關鍵字來覆寫父類別的方法。</p><pre><code class="hljs c#"><span class="hljs-comment">// 父類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>    &#123;        Name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">&quot;動物發出聲音&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 子類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span>    &#123;        <span class="hljs-comment">/*  這段程式碼是 Dog 類別的 public 建構函式，</span><span class="hljs-comment">            它接受一個字串參數 name，而「: base(name)」這部分是關鍵。</span><span class="hljs-comment">            :base() 語法用於呼叫父類別的建構函式。</span><span class="hljs-comment">            在這個例子中，它呼叫 Animal 類別的建構函式，並將 name 參數傳遞給父類別。</span><span class="hljs-comment"></span><span class="hljs-comment">          為什麼要這樣做?</span><span class="hljs-comment">            繼承性: Dog 類別繼承自 Animal 類別，所以它應該初始化從 Animal 繼承的所有屬性。</span><span class="hljs-comment">            重用代碼: 通過呼叫父類別的建構函式，我們可以避免重複編寫相同的初始化程式碼。</span><span class="hljs-comment">            保持一致性: 確保 Dog 物件的 Name 屬性(繼承自 Animal)且被正確初始化。 */</span>    &#125;    <span class="hljs-comment">// 覆寫父類別的方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> 汪汪叫&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        Animal genericAnimal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&quot;未知動物&quot;</span>);        Animal myDog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小白&quot;</span>);        genericAnimal.MakeSound(); <span class="hljs-comment">// 輸出：動物發出聲音</span>        myDog.MakeSound(); <span class="hljs-comment">// 輸出：小白 汪汪叫</span>    &#125;&#125;</code></pre><h3 id="5-舉例說明如何使用-this-和-base-關鍵字"><a href="#5-舉例說明如何使用-this-和-base-關鍵字" class="headerlink" title="5. 舉例說明如何使用 this 和 base 關鍵字"></a>5. 舉例說明如何使用 this 和 base 關鍵字</h3><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>    &#123;        <span class="hljs-keyword">this</span>.Name = name; <span class="hljs-comment">// this.Name = Animal.Name，在這邊 this 就是 Animal( this 會指向當前的物件 )。</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> 發出聲音&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Breed;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> breed</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>) <span class="hljs-comment">// 呼叫父類別 Animal 的建構函式，並傳遞 name 參數過去。</span></span>    &#123;        <span class="hljs-keyword">this</span>.Breed = breed;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span>    &#123;        <span class="hljs-keyword">base</span>.Speak(); <span class="hljs-comment">// 呼叫父類別 Animal 的 Speak 方法。</span>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;<span class="hljs-keyword">this</span>.Name&#125;</span> 汪汪叫&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        Dog myDog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小白&quot;</span>, <span class="hljs-string">&quot;哈士奇&quot;</span>);        myDog.Speak();  <span class="hljs-comment">// 輸出：小白 發出聲音</span>                        <span class="hljs-comment">// 輸出：小白 汪汪叫</span>    &#125;&#125;</code></pre><p>在這個例子中：</p><ol><li>this 的用法：</li></ol><ul><li>在 Animal 類別中：<code>this.Name = name;</code> 這裡使用 this 來區分屬性 Name 和參數 name。</li><li>在 Dog 類別中：<code>this.Breed = breed;</code> 同樣用於區分屬性和參數。</li><li>在 Dog 類的 Speak 方法中：<code>this.Name</code> 明確指出我們正在使用當前物件的 Name 屬性。</li></ul><ol start="2"><li>base 的用法：</li></ol><ul><li>在 Dog 的建構函式中：<code>:base(name)</code> 呼叫父類別 Animal 的建構函式，並傳遞 name 參數。</li><li>在 Dog 的 Speak 方法中：<code>base.Speak();</code> 呼叫父類別 Animal 的 Speak 方法。</li></ul><h3 id="6-給一個介面例子，其中一個類別實作該介面"><a href="#6-給一個介面例子，其中一個類別實作該介面" class="headerlink" title="6. 給一個介面例子，其中一個類別實作該介面"></a>6. 給一個介面例子，其中一個類別實作該介面</h3><pre><code class="hljs C#"><span class="hljs-comment">// 定義一個簡單的介面</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IAnimal</span> <span class="hljs-comment">// 「介面」的名稱會以大寫 I 開頭。</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span>;&#125;<span class="hljs-comment">// 實作介面的類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">IAnimal</span> <span class="hljs-comment">// 使用 「: IAnimal」 語法來表示 Dog 類別實作了 IAnimal 介面</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">&quot;汪汪!&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        IAnimal myDog = <span class="hljs-keyword">new</span> Dog();        myDog.MakeSound(); <span class="hljs-comment">// 輸出：汪汪!</span>    &#125;&#125;</code></pre><h3 id="7-如何在-C-中使用介面來實現多型？提供一個具體的例子"><a href="#7-如何在-C-中使用介面來實現多型？提供一個具體的例子" class="headerlink" title="7. 如何在 C# 中使用介面來實現多型？提供一個具體的例子"></a>7. 如何在 C# 中使用介面來實現多型？提供一個具體的例子</h3><p>這個例子展示了多型的運用</p><ol><li>定義一個 <code>IShape</code> 介面，它只有一個方法 <code>CalculateArea()</code>。</li><li>創建兩個類別 <code>Circle</code> 和 <code>Square</code>，它們都實作了 <code>IShape</code> 介面。</li><li>這兩個類別都實作了 <code>CalculateArea()</code> 方法：<br><code>Circle</code> 使用圓形面積公式 πr²<br><code>Square</code> 使用正方形面積公式 s²</li><li>在 Main 方法中，實例化一個圓形物件和一個正方形物件，但都將它們賦值給 <code>IShape</code> 型別的變數。</li><li><code>PrintArea()</code> 方法接受一個 <code>IShape</code> 型別的參數。這意味著它可以接收任何實作 <code>IShape</code> 介面的物件。</li><li>在 Main 方法中，呼叫 <code>PrintArea()</code> 方法，並傳遞 <code>IShape</code> 型別的變數來印出面積。</li><li>當我們呼叫 <code>PrintArea()</code> 方法時，它不用知道傳入的是圓形還是正方形，只需要知道這個物件實作了 <code>IShape</code> 介面，因此一定有 <code>CalculateArea()</code> 方法即可。</li></ol><pre><code class="hljs C#"><span class="hljs-comment">// 定義一個介面</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span>&#123;    <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">CalculateArea</span>()</span>;&#125;<span class="hljs-comment">// 實作介面的圓形類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span>    &#123;        Radius = radius;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">CalculateArea</span>()</span>    &#123;        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;    &#125;&#125;<span class="hljs-comment">// 實作介面的正方形類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> : <span class="hljs-title">IShape</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Side &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> side</span>)</span>    &#123;        Side = side;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">CalculateArea</span>()</span>    &#123;        <span class="hljs-keyword">return</span> Side * Side;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintArea</span>(<span class="hljs-params">IShape shape</span>)</span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;面積是: <span class="hljs-subst">&#123;shape.CalculateArea():F2&#125;</span>&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        IShape circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);        IShape square = <span class="hljs-keyword">new</span> Square(<span class="hljs-number">4</span>);        PrintArea(circle);  <span class="hljs-comment">// 輸出圓形的面積</span>        PrintArea(square);  <span class="hljs-comment">// 輸出正方形的面積</span>    &#125;&#125;</code></pre><h3 id="8-在-C-中，當一個類別被聲明為-sealed-時，其成員（方法、屬性等）還可以被覆寫嗎？解釋原因"><a href="#8-在-C-中，當一個類別被聲明為-sealed-時，其成員（方法、屬性等）還可以被覆寫嗎？解釋原因" class="headerlink" title="8. 在 C# 中，當一個類別被聲明為 sealed 時，其成員（方法、屬性等）還可以被覆寫嗎？解釋原因"></a>8. 在 C# 中，當一個類別被聲明為 sealed 時，其成員（方法、屬性等）還可以被覆寫嗎？解釋原因</h3><p>在 <code>C#</code> 中，當一個類別被宣告為 <code>sealed</code> 時，這個類別無法被繼承，<br>也因為沒辦法被繼承，所以其成員（方法、屬性等）無法被其他類別複寫。</p><h3 id="9-解釋靜態修飾詞-static-在-C-中何時會被使用，並給出一個例子"><a href="#9-解釋靜態修飾詞-static-在-C-中何時會被使用，並給出一個例子" class="headerlink" title="9. 解釋靜態修飾詞 static 在 C# 中何時會被使用，並給出一個例子"></a>9. 解釋靜態修飾詞 static 在 C# 中何時會被使用，並給出一個例子</h3><p>在 C#中，靜態修飾詞 static 主要在以下情況下使用：</p><ol><li><p>共享資源：當需要一個在所有類別實例間共享某個資源，可以使用靜態修飾詞。</p></li><li><p>工具方法：當方法不需要實例化就可以直接取用時。</p></li><li><p>常數：定義好且不會改變的值。</p></li></ol><p>下面是一個簡單的例子：</p><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathHelper</span>&#123;    <span class="hljs-comment">// 靜態常數</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">double</span> PI = <span class="hljs-number">3.14159</span>;    <span class="hljs-comment">// 靜態變量，用於計數方法被調用的次數</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> calculationCount = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 靜態方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">CalculateCircleArea</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span>    &#123;        calculationCount++; <span class="hljs-comment">// 增加計數</span>        <span class="hljs-keyword">return</span> PI * radius * radius;    &#125;    <span class="hljs-comment">// 靜態方法，用於獲取計算次數</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetCalculationCount</span>()</span>    &#123;        <span class="hljs-keyword">return</span> calculationCount;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        <span class="hljs-comment">// 使用靜態方法，無需創建類別實例</span>        <span class="hljs-built_in">double</span> area1 = MathHelper.CalculateCircleArea(<span class="hljs-number">5</span>);        Console.WriteLine(<span class="hljs-string">$&quot;圓的面積: <span class="hljs-subst">&#123;area1&#125;</span>&quot;</span>);        <span class="hljs-built_in">double</span> area2 = MathHelper.CalculateCircleArea(<span class="hljs-number">3</span>);        Console.WriteLine(<span class="hljs-string">$&quot;另一個圓的面積: <span class="hljs-subst">&#123;area2&#125;</span>&quot;</span>);        <span class="hljs-comment">// 獲取計算次數</span>        <span class="hljs-built_in">int</span> count = MathHelper.GetCalculationCount();        Console.WriteLine(<span class="hljs-string">$&quot;計算次數: <span class="hljs-subst">&#123;count&#125;</span>&quot;</span>);    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    輸出結果：</span><span class="hljs-comment">        圓的面積: 78.53975</span><span class="hljs-comment">        另一個圓的面積: 28.27431</span><span class="hljs-comment">        計算次數: 2</span><span class="hljs-comment">*/</span></code></pre><h3 id="10-給出一個範例，展示如何通過自動實作屬性來簡化代碼"><a href="#10-給出一個範例，展示如何通過自動實作屬性來簡化代碼" class="headerlink" title="10.給出一個範例，展示如何通過自動實作屬性來簡化代碼"></a>10.給出一個範例，展示如何通過自動實作屬性來簡化代碼</h3><p>先看一個不使用自動實作屬性的傳統方法：</p><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name    &#123;        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;        <span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age    &#123;        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> age; &#125;        <span class="hljs-keyword">set</span> &#123; age = <span class="hljs-keyword">value</span>; &#125;    &#125;&#125;</code></pre><p>改成使用自動實作屬性的方法：</p><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;&#125;</code></pre><h3 id="11-解釋何時應該使用-readonly-屬性，並給出一個例子"><a href="#11-解釋何時應該使用-readonly-屬性，並給出一個例子" class="headerlink" title="11.解釋何時應該使用 readonly 屬性，並給出一個例子"></a>11.解釋何時應該使用 readonly 屬性，並給出一個例子</h3><p><code>readonly</code> 關鍵字，在 C# 中通常用在類別的屬性上，此屬性只能在初始化時指派值。<br>以下是使用 readonly 的時機：</p><ol><li>常數值：當一個值在物件生命週期內不應該變動時。</li><li>相依性注入：當一個物件在建構時被注入，之後不應被更改時。</li><li>提升效能：編譯器可以對 <code>readonly</code> 欄位進行最佳化。</li><li>執行緒安全：<code>readonly</code> 欄位在多執行緒環境中較為安全，因為它們在初始化後不會改變。</li><li>程式碼清晰度：明確表示某個欄位不應在初始化後被修改。</li></ol><p>以下是個簡單的例子：</p><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&#123;    <span class="hljs-comment">// readonly 欄位，學號不可變</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> studentId;    <span class="hljs-comment">// 可變欄位</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 建構子</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> id, <span class="hljs-built_in">string</span> name</span>)</span>    &#123;        studentId = id;        Name = name;    &#125;    <span class="hljs-comment">// 取得學號的方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetStudentId</span>()</span>    &#123;        <span class="hljs-keyword">return</span> studentId;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;S001&quot;</span>, <span class="hljs-string">&quot;小明&quot;</span>);        Console.WriteLine(<span class="hljs-string">$&quot;學生姓名：<span class="hljs-subst">&#123;student.Name&#125;</span>&quot;</span>);        Console.WriteLine(<span class="hljs-string">$&quot;學號：<span class="hljs-subst">&#123;student.GetStudentId()&#125;</span>&quot;</span>);        <span class="hljs-comment">// 可以更改名字</span>        student.Name = <span class="hljs-string">&quot;大明&quot;</span>;        Console.WriteLine(<span class="hljs-string">$&quot;更改後的姓名：<span class="hljs-subst">&#123;student.Name&#125;</span>&quot;</span>);        <span class="hljs-comment">// 以下程式碼會導致編譯錯誤，因為 studentId 是 readonly</span>        <span class="hljs-comment">// student.studentId = &quot;S002&quot;; // 錯誤</span>    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    輸出結果：</span><span class="hljs-comment">        學生姓名：小明</span><span class="hljs-comment">        學號：S001</span><span class="hljs-comment">        更改後的姓名：大明</span><span class="hljs-comment">*/</span></code></pre><p>在這個例子中：</p><ol><li><code>studentId</code> 被宣告為 <code>readonly</code>，表示它只能在建構子中設定，之後就不能更改。</li><li><code>Name</code> 是一個普通的屬性，可以隨時更改。</li><li>建構子接受學號和姓名，並設定相應的欄位。</li><li><code>GetStudentId()</code> 方法用來取得學號，因為 <code>studentId</code> 是私有的。</li><li>在 <code>Main</code> 方法中，我們可以建立 <code>Student</code> 的實例，讀取學號，更改姓名，但不能更改學號。</li></ol><p>這個例子簡單地展示了 <code>readonly</code> 的用途：</p><ul><li>確保重要的識別資訊（如學號）在物件建立後不會被更改。</li><li>同時允許其他資訊（如姓名）保持可變。</li></ul><h3 id="12-示範如何在-C-中重載一個類別的建構函式並解釋其目的"><a href="#12-示範如何在-C-中重載一個類別的建構函式並解釋其目的" class="headerlink" title="12.示範如何在 C# 中重載一個類別的建構函式並解釋其目的"></a>12.示範如何在 C# 中重載一個類別的建構函式並解釋其目的</h3><p>以一個簡單的 Person 類別為例。</p><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> City &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 建構函式 1：沒有參數</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>()</span>    &#123;        Name = <span class="hljs-string">&quot;未知&quot;</span>;        Age = <span class="hljs-number">0</span>;        City = <span class="hljs-string">&quot;未知&quot;</span>;    &#125;    <span class="hljs-comment">// 建構函式 2：有名字參數</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>    &#123;        Name = name;        Age = <span class="hljs-number">0</span>;        City = <span class="hljs-string">&quot;未知&quot;</span>;    &#125;    <span class="hljs-comment">// 建構函式 3：有名字和年齡參數</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span>    &#123;        Name = name;        Age = age;        City = <span class="hljs-string">&quot;未知&quot;</span>;    &#125;    <span class="hljs-comment">// 建構函式 4：有名字、年齡和城市參數</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> city</span>)</span>    &#123;        Name = name;        Age = age;        City = city;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        Person person1 = <span class="hljs-keyword">new</span> Person();        Person person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小明&quot;</span>);        Person person3 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小華&quot;</span>, <span class="hljs-number">25</span>);        Person person4 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小李&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&quot;台北&quot;</span>);        Console.WriteLine(<span class="hljs-string">$&quot;Person1: <span class="hljs-subst">&#123;person1.Name&#125;</span>, <span class="hljs-subst">&#123;person1.Age&#125;</span>, <span class="hljs-subst">&#123;person1.City&#125;</span>&quot;</span>);        Console.WriteLine(<span class="hljs-string">$&quot;Person2: <span class="hljs-subst">&#123;person2.Name&#125;</span>, <span class="hljs-subst">&#123;person2.Age&#125;</span>, <span class="hljs-subst">&#123;person2.City&#125;</span>&quot;</span>);        Console.WriteLine(<span class="hljs-string">$&quot;Person3: <span class="hljs-subst">&#123;person3.Name&#125;</span>, <span class="hljs-subst">&#123;person3.Age&#125;</span>, <span class="hljs-subst">&#123;person3.City&#125;</span>&quot;</span>);        Console.WriteLine(<span class="hljs-string">$&quot;Person4: <span class="hljs-subst">&#123;person4.Name&#125;</span>, <span class="hljs-subst">&#123;person4.Age&#125;</span>, <span class="hljs-subst">&#123;person4.City&#125;</span>&quot;</span>);    &#125;&#125;</code></pre><p>解釋建構函式多載的目的：</p><ol><li><p>彈性初始化：<br>允許以不同的方式初始化物件，根據可用的資訊量。<br>使用者可以選擇最適合他們需求的建構函式。</p></li><li><p>預設值處理：<br>對於未提供的資訊，可以設定合理的預設值。</p></li><li><p>程式碼重用：<br>較複雜的建構函式可以呼叫較簡單的建構函式，減少重複程式碼。</p></li><li><p>向後相容性：<br>在維護或擴展類別時，可以新增建構函式而不影響現有的程式碼。</p></li><li><p>提高可讀性：<br>明確地表示物件可以用不同的方式被建立，使程式碼更易懂。</p></li></ol><p>參數驗證：<br>可以在不同的建構函式中執行不同的參數驗證邏輯。<br>多載建構函式讓類別的使用更加靈活，能夠適應不同的使用場景。這種方法在建立複雜物件或當物件的初始化可能有多種形式時特別有用。</p><h3 id="13-請提供一個包含屬性的介面的例子"><a href="#13-請提供一個包含屬性的介面的例子" class="headerlink" title="13.請提供一個包含屬性的介面的例子"></a>13.請提供一個包含屬性的介面的例子</h3><p>設計一個簡單的 IProduct 介面，代表基本的產品資訊。</p><pre><code class="hljs C#"><span class="hljs-comment">// 產品介面</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IProduct</span>&#123;    <span class="hljs-comment">// 產品編號</span>    <span class="hljs-built_in">string</span> Id &#123; <span class="hljs-keyword">get</span>; &#125;    <span class="hljs-comment">// 產品名稱</span>    <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 產品價格</span>    <span class="hljs-built_in">decimal</span> Price &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 檢查產品是否有庫存</span>    <span class="hljs-built_in">bool</span> IsInStock &#123; <span class="hljs-keyword">get</span>; &#125;&#125;<span class="hljs-comment">// 實作介面的類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> : <span class="hljs-title">IProduct</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Id &#123; <span class="hljs-keyword">get</span>; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Price &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsInStock &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 建構函式</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> id, <span class="hljs-built_in">string</span> name, <span class="hljs-built_in">decimal</span> price</span>)</span>    &#123;        Id = id;        Name = name;        Price = price;        IsInStock = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 預設有庫存</span>    &#125;    <span class="hljs-comment">// 更新庫存狀態的方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateStock</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> inStock</span>)</span>    &#123;        IsInStock = inStock;    &#125;&#125;<span class="hljs-comment">// 使用範例</span><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        IProduct book = <span class="hljs-keyword">new</span> Book(<span class="hljs-string">&quot;B001&quot;</span>, <span class="hljs-string">&quot;C# 程式設計&quot;</span>, <span class="hljs-number">500</span>m);        Console.WriteLine(<span class="hljs-string">$&quot;產品編號: <span class="hljs-subst">&#123;book.Id&#125;</span>&quot;</span>);        Console.WriteLine(<span class="hljs-string">$&quot;產品名稱: <span class="hljs-subst">&#123;book.Name&#125;</span>&quot;</span>);        Console.WriteLine(<span class="hljs-string">$&quot;價格: $<span class="hljs-subst">&#123;book.Price&#125;</span>&quot;</span>);        Console.WriteLine(<span class="hljs-string">$&quot;是否有庫存: <span class="hljs-subst">&#123;book.IsInStock&#125;</span>&quot;</span>);    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    產品編號: B001</span><span class="hljs-comment">        產品名稱: C# 程式設計</span><span class="hljs-comment">        價格: $500</span><span class="hljs-comment">        是否有庫存: True</span><span class="hljs-comment">*/</span></code></pre><h3 id="14-什麼是-sealed-類別，並解釋其如何用來限制繼承。"><a href="#14-什麼是-sealed-類別，並解釋其如何用來限制繼承。" class="headerlink" title="14.什麼是 sealed 類別，並解釋其如何用來限制繼承。"></a>14.什麼是 sealed 類別，並解釋其如何用來限制繼承。</h3><p>在 C# 中，<code>sealed</code> 類別是一種特殊的類別，它被設計用來防止其他類別繼承它。<br>當一個類別被宣告為 <code>sealed</code> 時，它就成為了繼承鏈的終點。</p><ol><li>sealed 類別的定義：使用 sealed 關鍵字來宣告一個類別</li></ol><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SealedClass</span>&#123;    <span class="hljs-comment">// 類別成員</span>&#125;</code></pre><ol start="2"><li>限制繼承的方式：<br>當一個類別被宣告為 sealed，其他類別就不能繼承它。<br>如果嘗試繼承一個 sealed 類別，編譯器會產生錯誤，如下例子：</li></ol><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SealedClass</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SealedMethod</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">&quot;這是密封類別中的方法&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 以下程式碼會導致編譯錯誤</span><span class="hljs-comment">// public class AttemptToInherit : SealedClass</span><span class="hljs-comment">// &#123;</span><span class="hljs-comment">//     // 無法繼承 SealedClass</span><span class="hljs-comment">// &#125;</span></code></pre><ol start="3"><li><p>sealed 類別的用途：<br>防止意外或不當的繼承。<br>確保類別的行為不被修改或擴展。<br>在某些情況下可以提高性能，因為編譯器可以進行特定的優化。</p></li><li><p>注意事項：<br><code>sealed</code> 類別仍然可以繼承其他非 <code>sealed</code> 類別。<br><code>sealed</code> 類別可以實作介面。<br>類別中的個別方法也可以被宣告為 <code>sealed</code>，以防止在子類別中被覆寫。</p></li><li><p>使用場景：<br>當你設計一個不應該被繼承的類別時，例如工具類別或特定的業務邏輯類別。<br>在安全性要求高的場景中，防止類別被繼承和修改，如下例子：</p></li></ol><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SecurityManager</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PerformSecureOperation</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">&quot;執行安全操作&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        SecurityManager manager = <span class="hljs-keyword">new</span> SecurityManager();        manager.PerformSecureOperation();    &#125;&#125;</code></pre><p>總結來說，<code>sealed</code> 類別提供了一種方法來限制類別的繼承，這在某些設計情境中是很有用的，特別是當你需要確保類別的行為不被更改或擴展時。但是使用 <code>sealed</code> 類別也會限制程式的靈活性，所以在決定使用時需要權衡利弊。</p><h3 id="15-解釋-C-中繼承的概念並給出一個簡單範例。"><a href="#15-解釋-C-中繼承的概念並給出一個簡單範例。" class="headerlink" title="15.解釋 C# 中繼承的概念並給出一個簡單範例。"></a>15.解釋 C# 中繼承的概念並給出一個簡單範例。</h3><p>繼承是物件導向程式設計中的一個核心概念。<br>在 C# 中，繼承允許我們創建一個新的類別（稱為子類別或衍生類別），該類別基於一個現有的類別（稱為父類別或基礎類別）。<br>子類別繼承了父類別的屬性和方法，同時可以添加自己的新成員或覆寫父類別的成員。</p><p>繼承的主要優點：</p><ol><li>代碼重用：避免重複編寫相同的代碼。</li><li>建立層次結構：允許創建更專門化的類別。</li><li>多型性：允許使用父類別型別來引用子類別物件。</li></ol><p>簡單的範例來說明繼承：</p><pre><code class="hljs C#"><span class="hljs-comment">// 基礎類別（父類別）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Color &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shape</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color</span>)</span>    &#123;        Color = color;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;畫一個<span class="hljs-subst">&#123;Color&#125;</span>色的形狀&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 衍生類別（子類別）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">Shape</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">color</span>)</span>    &#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;畫一個<span class="hljs-subst">&#123;Color&#125;</span>色的圓形&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        Shape shape = <span class="hljs-keyword">new</span> Shape(<span class="hljs-string">&quot;紅&quot;</span>);        shape.Draw();  <span class="hljs-comment">// 輸出：畫一個紅色的形狀</span>        Circle circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-string">&quot;藍&quot;</span>);        circle.Draw();  <span class="hljs-comment">// 輸出：畫一個藍色的圓形</span>        <span class="hljs-comment">// 多型示範</span>        Shape shapeCircle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-string">&quot;綠&quot;</span>);        shapeCircle.Draw();  <span class="hljs-comment">// 輸出：畫一個綠色的圓形</span>    &#125;&#125;</code></pre><h3 id="16-解釋抽象類別，並給出一個抽象類別的例子。"><a href="#16-解釋抽象類別，並給出一個抽象類別的例子。" class="headerlink" title="16.解釋抽象類別，並給出一個抽象類別的例子。"></a>16.解釋抽象類別，並給出一個抽象類別的例子。</h3><p>抽象類別是一種特殊的類別，它不能被直接實例化，主要用於定義其他類別的共同特徵。<br>抽象類別可以包含抽象方法（沒有實作的方法）和具體方法（有實作的方法）。</p><p>抽象類別的主要特點：</p><ol><li>使用 <code>abstract</code> 關鍵字宣告。</li><li>不能被直接實例化。</li><li>可以包含抽象方法和具體方法。</li><li>子類別必須實作所有抽象方法，除非子類別也是抽象類別。</li><li>可以包含屬性和欄位。</li></ol><p>以下是一個抽象類別的例子：</p><pre><code class="hljs C#"><span class="hljs-comment">// 抽象類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span>&#123;    <span class="hljs-comment">// 屬性</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Color &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 建構函式</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Shape</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color</span>)</span>    &#123;        Color = color;    &#125;    <span class="hljs-comment">// 抽象方法（沒有實作）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">double</span> <span class="hljs-title">CalculateArea</span>()</span>;    <span class="hljs-comment">// 具體方法（有實作）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayInfo</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;這是一個<span class="hljs-subst">&#123;Color&#125;</span>色的形狀&quot;</span>);    &#125;&#125;</code></pre><h3 id="17-描述如何使用抽象方法強制子類別提供特定功能的實現。"><a href="#17-描述如何使用抽象方法強制子類別提供特定功能的實現。" class="headerlink" title="17. 描述如何使用抽象方法強制子類別提供特定功能的實現。"></a>17. 描述如何使用抽象方法強制子類別提供特定功能的實現。</h3><pre><code class="hljs C#"><span class="hljs-comment">// 抽象類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span>&#123;    <span class="hljs-comment">// 屬性</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Color &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 建構函式</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Shape</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color</span>)</span>    &#123;        Color = color;    &#125;    <span class="hljs-comment">// 抽象方法（沒有實作）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">double</span> <span class="hljs-title">CalculateArea</span>()</span>;    <span class="hljs-comment">// 具體方法（有實作）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayInfo</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;這是一個<span class="hljs-subst">&#123;Color&#125;</span>色的形狀&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 繼承抽象類別的具體類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">Shape</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color, <span class="hljs-built_in">double</span> radius</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">color</span>)</span>    &#123;        Radius = radius;    &#125;    <span class="hljs-comment">// 實作抽象方法，必須實作 CalculateArea() 這個抽象方法。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">double</span> <span class="hljs-title">CalculateArea</span>()</span>    &#123;        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;    &#125;    <span class="hljs-comment">// 選擇性覆寫具體方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayInfo</span>()</span>    &#123;        <span class="hljs-keyword">base</span>.DisplayInfo();        Console.WriteLine(<span class="hljs-string">$&quot;這是一個半徑為 <span class="hljs-subst">&#123;Radius&#125;</span> 的圓&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        <span class="hljs-comment">// Shape shape = new Shape(&quot;紅色&quot;); // 這行會造成編譯錯誤，因為抽象類別不能被實例化</span>        Circle circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-string">&quot;藍色&quot;</span>, <span class="hljs-number">5</span>);        circle.DisplayInfo();        Console.WriteLine(<span class="hljs-string">$&quot;圓的面積是: <span class="hljs-subst">&#123;circle.CalculateArea()&#125;</span>&quot;</span>);    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    輸出結果：</span><span class="hljs-comment">        這是一個藍色色的形狀</span><span class="hljs-comment">        這是一個半徑為 5 的圓</span><span class="hljs-comment">        圓的面積是: 78.5398163397448</span><span class="hljs-comment">*/</span></code></pre><p>在這個例子中：</p><ol><li><p>Shape 是一個抽象類別：<br>它有一個 Color 屬性。<br>包含一個抽象方法 CalculateArea()。<br>包含一個具體方法 DisplayInfo()。</p></li><li><p>Circle 類別繼承自 Shape：<br>必須實作 CalculateArea() 方法。<br>可以選擇性地覆寫 DisplayInfo() 方法。</p></li><li><p>在 Main 方法中：<br>我們不能直接實例化 Shape。<br>我們可以創建 Circle 的實例並使用其方法。</p></li></ol><h3 id="18-給出一個範例，展示如何在子類別中使用-base-來調用基類的構造函數。"><a href="#18-給出一個範例，展示如何在子類別中使用-base-來調用基類的構造函數。" class="headerlink" title="18. 給出一個範例，展示如何在子類別中使用 base 來調用基類的構造函數。"></a>18. 給出一個範例，展示如何在子類別中使用 base 來調用基類的構造函數。</h3><p>這邊提供一個簡單的例子來說明如何使用 base 調用基底類別的建構函式。<br>以動物類別為例：</p><pre><code class="hljs C#"><span class="hljs-comment">// 基類（父類別）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 基底類別的建構函式</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>    &#123;        Name = name;        Console.WriteLine(<span class="hljs-string">$&quot;動物 <span class="hljs-subst">&#123;Name&#125;</span> 被創建了&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 子類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Breed &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-comment">// 子類別的建構函式，使用 base 呼叫父類別的建構函式</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> breed</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span>    &#123;        Breed = breed;        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> 是一隻 <span class="hljs-subst">&#123;Breed&#125;</span>&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        Dog myDog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;小白&quot;</span>, <span class="hljs-string">&quot;哈士奇&quot;</span>);    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    輸出結果：</span><span class="hljs-comment">        動物 小白 被創建了</span><span class="hljs-comment">        小白 是一隻 哈士奇</span><span class="hljs-comment">*/</span></code></pre><h3 id="19-舉例說明如何通過一個類別來實作多個介面。"><a href="#19-舉例說明如何通過一個類別來實作多個介面。" class="headerlink" title="19.舉例說明如何通過一個類別來實作多個介面。"></a>19.舉例說明如何通過一個類別來實作多個介面。</h3><p>使用一個學生類別來展示這個概念：</p><pre><code class="hljs C#"><span class="hljs-comment">// 介面 1：可學習的</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ILearner</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Study</span>()</span>;&#125;<span class="hljs-comment">// 介面 2：可參與運動的</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IAthlete</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Play</span>()</span>;&#125;<span class="hljs-comment">// 實作多個介面的類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> : <span class="hljs-title">ILearner</span>, <span class="hljs-title">IAthlete</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>    &#123;        Name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Study</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> 正在學習。&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Play</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> 正在運動。&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;小明&quot;</span>);        <span class="hljs-comment">// 使用 ILearner 介面的方法</span>        student.Study();        <span class="hljs-comment">// 使用 IAthlete 介面的方法</span>        student.Play();        <span class="hljs-comment">// 展示多型性</span>        ILearner learner = student;        IAthlete athlete = student;        learner.Study();        athlete.Play();    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    輸出結果：</span><span class="hljs-comment">        小明 正在學習。</span><span class="hljs-comment">        小明 正在運動。</span><span class="hljs-comment">        小明 正在學習。</span><span class="hljs-comment">        小明 正在運動。</span><span class="hljs-comment">*/</span></code></pre><ol><li>定義了兩個簡單的介面：ILearner 和 IAthlete。</li><li>Student 類別實作了這兩個介面：</li></ol><pre><code class="hljs C#">csharpCopypublic <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> : <span class="hljs-title">ILearner</span>, <span class="hljs-title">IAthlete</span></code></pre><ol start="3"><li>Student 類別提供了這兩個介面中定義的方法的實作。</li><li>在 Main 方法中，我們展示了：<br>如何創建 Student 物件並呼叫實作的介面方法。<br>如何將 Student 物件指派給不同介面類型的變數（多型性）。</li></ol><h3 id="20-介面與抽象類別有什麼不同？"><a href="#20-介面與抽象類別有什麼不同？" class="headerlink" title="20.介面與抽象類別有什麼不同？"></a>20.介面與抽象類別有什麼不同？</h3><ol><li><p>定義方式：<br>抽象類別：使用 abstract class 關鍵字定義。<br>介面：使用 interface 關鍵字定義。</p></li><li><p>實作：<br>抽象類別：可以包含抽象方法和具體方法。<br>介面：在 C# 8.0 之前，只能包含抽象方法。從 C# 8.0 開始，可以包含預設實作。</p></li><li><p>繼承：<br>抽象類別：一個類別只能繼承一個抽象類別。<br>介面：一個類別可以實作多個介面。</p></li><li><p>建構函式：<br>抽象類別：可以有建構函式。<br>介面：不能有建構函式。</p></li><li><p>存取修飾詞：<br>抽象類別：可以使用各種存取修飾詞（public, protected, internal 等）。<br>介面：成員默認是 public，不能使用其他存取修飾詞。</p></li><li><p>用途：<br>抽象類別：用於表示 “是一種” (is-a) 關係，提供基本實作。<br>介面：用於定義 “能做什麼” (can-do) 的規範，專注於行為。</p></li></ol><h3 id="21-介面可以定義構造函數嗎？"><a href="#21-介面可以定義構造函數嗎？" class="headerlink" title="21. 介面可以定義構造函數嗎？"></a>21. 介面可以定義構造函數嗎？</h3><p>不可以</p><h3 id="22-請說明介面可以透過繼承而加以擴展。"><a href="#22-請說明介面可以透過繼承而加以擴展。" class="headerlink" title="22. 請說明介面可以透過繼承而加以擴展。"></a>22. 請說明介面可以透過繼承而加以擴展。</h3><pre><code class="hljs C#"><span class="hljs-comment">// 基礎介面</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IBasicAnimal</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sleep</span>()</span>;&#125;<span class="hljs-comment">// 可行走的介面</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IWalkable</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Walk</span>()</span>;&#125;<span class="hljs-comment">// 擴展的介面，繼承自 IBasicAnimal 和 IWalkable</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDog</span> : <span class="hljs-title">IBasicAnimal</span>, <span class="hljs-title">IWalkable</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span>;&#125;<span class="hljs-comment">// 實作 IDog 介面的類別</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">IDog</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">&quot;狗在吃東西&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sleep</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">&quot;狗在睡覺&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Walk</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">&quot;狗在走路&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span>    &#123;        Console.WriteLine(<span class="hljs-string">&quot;汪汪！&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>    &#123;        IDog myDog = <span class="hljs-keyword">new</span> Dog();        myDog.Eat();    <span class="hljs-comment">// 從 IBasicAnimal 繼承</span>        myDog.Sleep();  <span class="hljs-comment">// 從 IBasicAnimal 繼承</span>        myDog.Walk();   <span class="hljs-comment">// 從 IWalkable 繼承</span>        myDog.Bark();   <span class="hljs-comment">// IDog 特有的</span>        <span class="hljs-comment">// 展示多型性</span>        IBasicAnimal basicAnimal = myDog;        basicAnimal.Eat();        IWalkable walkable = myDog;        walkable.Walk();    &#125;&#125;</code></pre><h3 id="23-在-C-中，一個類別實作介面時，必須實作介面的所有成員嗎？"><a href="#23-在-C-中，一個類別實作介面時，必須實作介面的所有成員嗎？" class="headerlink" title="23. 在 C# 中，一個類別實作介面時，必須實作介面的所有成員嗎？"></a>23. 在 C# 中，一個類別實作介面時，必須實作介面的所有成員嗎？</h3><p>對</p><h3 id="24-介面的成員默認的存取修飾詞是什麼？"><a href="#24-介面的成員默認的存取修飾詞是什麼？" class="headerlink" title="24. 介面的成員默認的存取修飾詞是什麼？"></a>24. 介面的成員默認的存取修飾詞是什麼？</h3><p>在 C# 中，介面的成員（方法、屬性、事件等）默認的存取修飾詞是 <code>public</code>。</p><h3 id="25-在多層繼承結構中，如何確保父類別的某些方法不能被某個特定層級的子類或所有子類覆寫？"><a href="#25-在多層繼承結構中，如何確保父類別的某些方法不能被某個特定層級的子類或所有子類覆寫？" class="headerlink" title="25. 在多層繼承結構中，如何確保父類別的某些方法不能被某個特定層級的子類或所有子類覆寫？"></a>25. 在多層繼承結構中，如何確保父類別的某些方法不能被某個特定層級的子類或所有子類覆寫？</h3><p>主要有兩種方式來實現您描述的需求：</p><ol><li>使用 sealed 關鍵字</li><li>不使用 virtual 關鍵字</li></ol>]]></content>
      
      
      <categories>
          
          <category> 物件導向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP 的四個特性</title>
      <link href="/2024/07/30/OOP-%E7%9A%84%E5%9B%9B%E5%80%8B%E7%89%B9%E6%80%A7/"/>
      <url>/2024/07/30/OOP-%E7%9A%84%E5%9B%9B%E5%80%8B%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="物件導向程式設計的四個特性"><a href="#物件導向程式設計的四個特性" class="headerlink" title="物件導向程式設計的四個特性"></a>物件導向程式設計的四個特性</h2><ul><li><p><strong>抽象( Abstraction )</strong></p><ul><li>將真實世界的需求轉換為 OOP 中的類別</li><li>類別包含 <strong>狀態(屬性)</strong> 與 <strong>行為(方法)</strong></li></ul></li><li><p><strong>封裝( Encapsulation )</strong></p><ul><li>隱藏&#x2F;保護內部實作細節，可以對屬性或方法設定存取層級 ( public、private、protected )</li></ul></li><li><p><strong>繼承( Inheritance )</strong></p><ul><li>可讓您根據某個類別建立新類別，增加複用性、擴充性，必要時還可以修改(覆寫)類別中定義的行為。</li></ul></li><li><p><strong>多型( Polymorphism )</strong></p><ul><li>在相同的介面下，可以用不同的型別來實現。</li><li>多型有分成好幾種不同類型。</li></ul></li></ul><h2 id="從需求或規格中進行-「抽象化的過程」"><a href="#從需求或規格中進行-「抽象化的過程」" class="headerlink" title="從需求或規格中進行 「抽象化的過程」"></a>從需求或規格中進行 「抽象化的過程」</h2><ol><li>假設我們要建立新客戶的管理系統。</li><li>該系統會管理商業、住宅、政府、教育類型的 <span style="color:red">客戶</span>。</li><li>我們必須最小程度地紀錄客戶的 <code>姓名</code>、<code>姓氏</code>、<code>名字</code>、<code>電子郵件地址</code>、<code>住家地址</code>、<code>工作地址</code>等資訊。</li><li>我們還需要管理<span style="color:red">產品</span>，因此也需要最小程度地記錄<code>產品名稱</code>、<code>描述</code>、<code>價格</code> 等資訊。</li></ol><p><img src="/2024/07/30/OOP-%E7%9A%84%E5%9B%9B%E5%80%8B%E7%89%B9%E6%80%A7/%E5%AE%A2%E6%88%B6%E3%80%81%E7%94%A2%E5%93%81.png"></p><h3 id="定義出類別"><a href="#定義出類別" class="headerlink" title="定義出類別"></a>定義出類別</h3><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> CustomerId &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> EmailAddress &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> HomeAddress &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> WorkAddress &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Validate</span>()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Save</span>()</span> &#123; &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Load</span>()</span> &#123; &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Product</span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ProductId &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> ProductName&#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> ProductDescription &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span>? CurrentPrice&#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;&#125;</code></pre><h2 id="對實作的細節進行「封裝」"><a href="#對實作的細節進行「封裝」" class="headerlink" title="對實作的細節進行「封裝」"></a>對實作的細節進行「封裝」</h2>]]></content>
      
      
      <categories>
          
          <category> 物件導向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列方法：every()</title>
      <link href="/2024/07/28/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Aevery/"/>
      <url>/2024/07/28/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Aevery/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>every()</code> 方法會判斷所有元素是否都符合條件，在判斷過程中只要 callback function 回傳 <code>false</code> 就會停止遍歷，否則代表全部元素都符合條件，回傳 <code>true</code>。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>every()</code> 方法時要傳入一個 callback function，該 function 可傳入三個參數：</p><ol><li><strong>currentValue (必要)</strong> ：原陣列目前迭代挑到的元素。</li><li><strong>index (選擇性)</strong> ：原陣列目前迭代挑到的元素的索引。</li><li><strong>array (選擇性)</strong> ：原陣列本身。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> &#123;  <span class="hljs-comment">// do something</span>&#125;)</code></pre><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>檢查陣列中的元素是否都大於 10</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isBigEnough</span>(<span class="hljs-params">element, index, array</span>) &#123;  <span class="hljs-keyword">return</span> element &gt;= <span class="hljs-number">10</span>;&#125;[<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].<span class="hljs-title function_">every</span>(isBigEnough); <span class="hljs-comment">// false</span>[<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].<span class="hljs-title function_">every</span>(isBigEnough); <span class="hljs-comment">// true</span></code></pre><ol start="2"><li>判斷一個陣列中的元素是否為另一個陣列的子集</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isSubset</span> = (<span class="hljs-params">array1, array2</span>) =&gt;  array2.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> array1.<span class="hljs-title function_">includes</span>(element));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isSubset</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>])); <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isSubset</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>])); <span class="hljs-comment">// false</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 陣列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 陣列 </tag>
            
            <tag> 陣列方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列方法：find()</title>
      <link href="/2024/07/27/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Afind/"/>
      <url>/2024/07/27/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Afind/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>find()</code> 方法會回傳第一個滿足條件的元素 ( 只回傳一個元素 )，否則會回傳 <code>undefined</code>。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>find()</code> 方法時要傳入一個 callback function，該 function 可傳入三個參數：</p><ol><li><strong>currentValue (必要)</strong> ：原陣列目前迭代挑到的元素。</li><li><strong>index (選擇性)</strong> ：原陣列目前迭代挑到的元素的索引。</li><li><strong>array (選擇性)</strong> ：原陣列本身。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> &#123;  <span class="hljs-comment">// do something</span>&#125;)</code></pre><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>在陣列中查找某個符合條件的物件元素。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> inventory = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;apples&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">2</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bananas&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">0</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cherries&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">5</span> &#125;,];<span class="hljs-keyword">function</span> <span class="hljs-title function_">isCherries</span>(<span class="hljs-params">fruit</span>) &#123;  <span class="hljs-keyword">return</span> fruit.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;cherries&quot;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(inventory.<span class="hljs-title function_">find</span>(isCherries));<span class="hljs-comment">// &#123; name: &#x27;cherries&#x27;, quantity: 5 &#125;</span></code></pre><ol start="2"><li>在陣列中找質數</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">element, index, array</span>) &#123;  <span class="hljs-keyword">var</span> start = <span class="hljs-number">2</span>;  <span class="hljs-keyword">while</span> (start &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(element)) &#123;    <span class="hljs-keyword">if</span> (element % start++ &lt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/* start 變數會在判斷完後才 + 1 */</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> element &gt; <span class="hljs-number">1</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>].<span class="hljs-title function_">find</span>(isPrime)); <span class="hljs-comment">// undefined, not found</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>].<span class="hljs-title function_">find</span>(isPrime)); <span class="hljs-comment">// 5</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 陣列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 陣列 </tag>
            
            <tag> 陣列方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列方法：filter()</title>
      <link href="/2024/07/27/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Afilter/"/>
      <url>/2024/07/27/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Afilter/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>filter()</code> 方法會將陣列中的所有元素，依序地傳入一次至 callback function 中，並將回傳值為 Truthy 的元素建構成一個新的陣列，也就是篩選出符合條件的元素出來，並將這些元素塞進一個新的陣列裡。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>filter()</code> 方法時要傳入一個 callback function，該 function 可傳入三個參數：</p><ol><li><strong>currentValue (必要)</strong> ：原陣列目前迭代挑到的元素。</li><li><strong>index (選擇性)</strong> ：原陣列目前迭代挑到的元素的索引。</li><li><strong>array (選擇性)</strong> ：原陣列本身。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> &#123;  <span class="hljs-comment">// do something</span>&#125;)</code></pre><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>過濾小於 10 的數字。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isBigEnough</span>(<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">let</span> filtered = [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].<span class="hljs-title function_">filter</span>(isBigEnough);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filtered); <span class="hljs-comment">// 12, 130, 44</span></code></pre><ol start="2"><li>過濾 JSON 檔中無效的項目<br>以下範例會用 filter() 把 id 屬性為非數值型別的項目過濾掉。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">var</span> arr = [  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">15</span> &#125;,  &#123; <span class="hljs-attr">id</span>: -<span class="hljs-number">1</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">12.2</span> &#125;,  &#123;&#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-literal">null</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-title class_">NaN</span> &#125;,  &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;undefined&quot;</span> &#125;,];<span class="hljs-keyword">function</span> <span class="hljs-title function_">isNumber</span>(<span class="hljs-params">obj</span>) &#123;  <span class="hljs-keyword">return</span> obj !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;number&quot;</span> &amp;&amp; !<span class="hljs-built_in">isNaN</span>(obj);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">filterByID</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNumber</span>(item.<span class="hljs-property">id</span>)) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">var</span> arrByID = arr.<span class="hljs-title function_">filter</span>(filterByID);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;過濾好的陣列\n&quot;</span>, arrByID);<span class="hljs-comment">// 過濾好的陣列</span><span class="hljs-comment">// [&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 陣列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 陣列 </tag>
            
            <tag> 陣列方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列方法：reduce()</title>
      <link href="/2024/07/26/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Areduce/"/>
      <url>/2024/07/26/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Areduce/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>reduce()</code> 方法會針每一個目前迭代到的陣列元素 ( 空值除外 )，去執行 callback function，而 callback function 會接受 4 個參數：</p><ul><li><strong>accumulator</strong> ：累加器 ( 必填 )</li><li><strong>currentValue</strong> ：目前迭代到的元素 ( 必填 )</li><li><strong>index</strong> ：目前迭代到的元素的索引 ( 選擇性 )</li><li><strong>array</strong> ：陣列本身 ( 選擇性 )</li></ul><p>又其中 <code>accumulator</code> 與 <code>currentValue</code> 的初始值會有兩種不同的情況，呼叫 <code>reduce()</code> 時，有無提供 <code>initialValue</code>？（建議都要提供 <code>initialValue</code>，比較安全，可參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#%E6%8F%8F%E8%BF%B0">MDN Array.prototype.reduce()</a>）</p><ol><li><p>有提供 <code>initialValue</code>，則 <code>accumulator</code> 一開始的值會等於 <code>initialValue</code>，<code>currentValue</code> 會等於陣列中的第一個元素值。</p></li><li><p>未提供 <code>initialValue</code>，則 <code>accumulator</code> 一開始的值會等於陣列中的第一個元素值，<code>currentValue</code> 會等於陣列中的第二個元素值。</p></li></ol><p>然後在每一次迭代中，callback function 執行完後都會吐一個值，此值會成為下一次迭代的 <code>accumulator</code>的值。</p><p>當所有迭代都完成後，最後一次吐出來的 <code>accumulator</code> 的值，會是一個「加總」、「集合」等等。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>reduce()</code> 方法時可以帶入一個 <code>initialValue</code> 以及要傳入一個 callback function，該 function 可傳入四個參數：</p><ul><li><strong>accumulator</strong> ：累加器 ( 必填 )</li><li><strong>currentValue</strong> ：目前迭代到的元素 ( 必填 )</li><li><strong>index</strong> ：目前迭代到的元素的索引 ( 選擇性 )</li><li><strong>array</strong> ：陣列本身 ( 選擇性 )</li></ul><pre><code class="hljs JS"><span class="hljs-comment">// 傳統函式 ( 此例未提供 initialValue )</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(  <span class="hljs-keyword">function</span> (<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) &#123;    <span class="hljs-keyword">return</span> accumulator + currentValue;  &#125;,);<span class="hljs-comment">// 箭頭函式 ( 此例有提供 initialValue， initialValue 值為 10)</span>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> accumulator + currentValue;&#125;, <span class="hljs-number">10</span>);</code></pre><p>將上述的箭頭函式的例子，攤開每一次迭代的狀況，就如下表格：</p><table><thead><tr><th>callback 次數</th><th>accumulator</th><th>currentValue</th><th>currentIndex</th><th>array</th><th>return value</th></tr></thead><tbody><tr><td>first</td><td>10</td><td>2</td><td>0</td><td>[2, 4, 6, 8, 10]</td><td>10 + 2 &#x3D; 12</td></tr><tr><td>second</td><td>12</td><td>4</td><td>1</td><td>[2, 4, 6, 8, 10]</td><td>10 + 4 &#x3D; 14</td></tr><tr><td>third</td><td>14</td><td>6</td><td>2</td><td>[2, 4, 6, 8, 10]</td><td>14 + 6 &#x3D; 20</td></tr><tr><td>fourth</td><td>20</td><td>8</td><td>3</td><td>[2, 4, 6, 8, 10]</td><td>20 + 8 &#x3D; 28</td></tr><tr><td>fifth</td><td>28</td><td>10</td><td>4</td><td>[2, 4, 6, 8, 10]</td><td>28 + 10 &#x3D; 38</td></tr></tbody></table><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>加總所有陣列之元素值</li></ol><pre><code class="hljs JS"><span class="hljs-comment">// 傳統函式</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> accumulator + currentValue;&#125;, <span class="hljs-number">0</span>);<span class="hljs-comment">// 0 + 0 + 1 + 2 + 3 + 4 = 10，sum = 10。</span><span class="hljs-comment">// 箭頭函式</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> accumulator + currentValue;&#125;, <span class="hljs-number">0</span>);<span class="hljs-comment">// 0 + 0 + 1 + 2 + 3 + 4 = 10，sum = 10。</span></code></pre><ol start="2"><li>計算陣列中每個元素的重複次數，並以物件的形式顯示</li></ol><pre><code class="hljs JS"><span class="hljs-comment">// 傳統函式</span><span class="hljs-keyword">let</span> names = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Tiff&quot;</span>, <span class="hljs-string">&quot;Bruce&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>];<span class="hljs-keyword">let</span> countedNames = names.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">allNames, name</span>) &#123;  <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> allNames) &#123;    allNames[name]++;  &#125; <span class="hljs-keyword">else</span> &#123;    allNames[name] = <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> allNames;&#125;, &#123;&#125;);<span class="hljs-comment">// countedNames is: &#123; &#x27;Alice&#x27;: 2, &#x27;Bob&#x27;: 1, &#x27;Tiff&#x27;: 1, &#x27;Bruce&#x27;: 1 &#125;</span><span class="hljs-comment">// 箭頭函式</span><span class="hljs-keyword">let</span> names = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Tiff&quot;</span>, <span class="hljs-string">&quot;Bruce&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>];<span class="hljs-keyword">let</span> countedNames = names.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">allNames, name</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> allNames) &#123;    allNames[name]++;  &#125; <span class="hljs-keyword">else</span> &#123;    allNames[name] = <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> allNames;&#125;, &#123;&#125;);<span class="hljs-comment">// countedNames is: &#123; &#x27;Alice&#x27;: 2, &#x27;Bob&#x27;: 1, &#x27;Tiff&#x27;: 1, &#x27;Bruce&#x27;: 1 &#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 陣列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 陣列 </tag>
            
            <tag> 陣列方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列方法：map()</title>
      <link href="/2024/07/25/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Amap/"/>
      <url>/2024/07/25/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%EF%BC%9Amap/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>map()</code> 方法會將陣列中的所有元素，依序地傳入一次至 callback function 中，每一次的傳入都會 return 一個新的元素，並以此 callback function return 的所有新元素建構一個新的陣列。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>map()</code> 方法時要傳入一個 callback function，該 function 可傳入三個參數：</p><ol><li><strong>currentValue (必要)</strong> ：原陣列目前迭代挑到的元素。</li><li><strong>index (選擇性)</strong> ：原陣列目前迭代挑到的元素的索引。</li><li><strong>array (選擇性)</strong> ：原陣列本身。</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, array</span>) =&gt;</span> &#123;  <span class="hljs-comment">// do something</span>&#125;)</code></pre><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>回傳元素的平方</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * item);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [1, 4, 9, 16, 25]</span></code></pre><ol start="2"><li>將元素開根號</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>];<span class="hljs-keyword">var</span> roots = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">sqrt</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(roots); <span class="hljs-comment">// [1, 2, 3]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 陣列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 陣列 </tag>
            
            <tag> 陣列方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>型別 3：型別比較</title>
      <link href="/2024/07/23/%E5%9E%8B%E5%88%A5-3%EF%BC%9A%E5%9E%8B%E5%88%A5%E6%AF%94%E8%BC%83/"/>
      <url>/2024/07/23/%E5%9E%8B%E5%88%A5-3%EF%BC%9A%E5%9E%8B%E5%88%A5%E6%AF%94%E8%BC%83/</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 中，有兩種型別比較，分別是<strong>寬鬆比較</strong>和<strong>嚴格比較</strong>。</p><h2 id="嚴格比較的規則"><a href="#嚴格比較的規則" class="headerlink" title="嚴格比較的規則"></a>嚴格比較的規則</h2><p><strong>嚴格比較的規則：比較的兩個運算元，必須要有相同的「型別」和相同的「值」，才會回傳 true。</strong></p><p>不過也有部分屬於例外，以下是一些容易被混淆的案例：</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>);                     <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>);                       <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> === <span class="hljs-literal">null</span>);              <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; === &#123;&#125;);                       <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>) === <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// false</span></code></pre><ul><li><strong>NaN &#x3D;&#x3D;&#x3D; NaN</strong>：NaN (Not A Number) 在嚴格比較時，會不等於任何值，因此與 NaN 比較時，一樣會獲得 false 的結果；如果要判斷是否為 NaN，可改用 isNaN() 這個方法。</li><li><strong>+0 &#x3D;&#x3D;&#x3D; -0</strong>：正 0 跟負 0 都會被視為 0，因此在嚴格比較時，會獲得 true 的結果。</li><li><strong>undefined &#x3D;&#x3D;&#x3D; null</strong>：雖然這兩個有點像，但兩者根本是不同的型別，所以嚴格比較時，會獲得 false 的結果。</li><li>{} &#x3D;&#x3D;&#x3D; {}：物件在比較時是比較兩者的「參考位址」，所以兩個物件就算其結構完全一致，也會得到 false 的結果。</li><li>new Number(1) &#x3D;&#x3D;&#x3D; new Number(1)：當使用 new 運算子建立原型時，實際上所建立的型別是物件型別，因此兩個物件相比，都會得到 false 的結果。</li></ul><h2 id="寬鬆比較的規則"><a href="#寬鬆比較的規則" class="headerlink" title="寬鬆比較的規則"></a>寬鬆比較的規則</h2><p><strong>寬鬆比較的規則複雜一點，不同型別的比對規則都不太一樣。</strong></p><h3 id="Number、String、Boolean-型別的寬鬆比較規則"><a href="#Number、String、Boolean-型別的寬鬆比較規則" class="headerlink" title="Number、String、Boolean 型別的寬鬆比較規則"></a><span style="color:white; background-color: #2a2936; padding: 5px">Number、String、Boolean 型別的寬鬆比較規則</span></h3><p>數值、字串、布林這三者之間，在進行寬鬆比較的時候，<u>如果運算元並非相同型別，則會統一轉型為 <code>Number</code> 進行比對</u> 。<br>因此在比對的時候，可以假想將兩個比較值都套上 <code>Number()</code>，<br>例如：Number(‘1’) &#x3D; 1、Number(true) &#x3D; 1、Number(false) &#x3D; 0，<br>來看一些基本範例：</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-number">1</span>);       <span class="hljs-comment">// true，相當於 Number(&#x27;1&#x27;) == 1 =&gt; true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-literal">true</span>);    <span class="hljs-comment">// true，相當於 Number(&#x27;1&#x27;) == Number(true) =&gt; true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-literal">false</span>);   <span class="hljs-comment">// true，相當於 Number(&#x27;0&#x27;) == Number(false) =&gt; true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span> == <span class="hljs-literal">true</span>);   <span class="hljs-comment">// false，因為 Number(&#x27;2&#x27;) = 2，但是 Number(true) = 1，所以不相等</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">false</span> == <span class="hljs-number">0</span>);     <span class="hljs-comment">// true，相當於 Number(false) == 0 =&gt; true</span></code></pre><ul><li>‘1’ &#x3D;&#x3D; 1：因為 ‘1’ 會轉型別為數值 1，所以比對結果為 true。</li><li>‘1’ &#x3D;&#x3D; true：因為 ‘1’ 會轉型別為數值 1、true 會轉型別為數值 1，所以比對結果為 true。</li><li>‘0’ &#x3D;&#x3D; false：因為 ‘0’ 會轉型別為數值 0、false 會轉型別為數值 0，所以比對結果為 true。</li><li>‘2’ &#x3D;&#x3D; true：因為 ‘2’ 會轉型別為數值 2，true 會轉型別為數值 1，所以比對結果為 false。</li><li>false &#x3D;&#x3D; 0：因為 false 會轉型別數值 0，所以比對結果為 true。</li></ul><p><strong><u>記得當你遇到數值、字串、布林這三個型別在進行比較時，會轉型成「數值」型別，再進行比較。</u></strong></p><h3 id="Null、Undefined-型別的寬鬆比較規則"><a href="#Null、Undefined-型別的寬鬆比較規則" class="headerlink" title="Null、Undefined 型別的寬鬆比較規則"></a><span style="color:white; background-color: #2a2936; padding: 5px">Null、Undefined 型別的寬鬆比較規則</span></h3><p>null 及 undefined 時常會與 false 搞混，但在寬鬆比較時，它們幾乎是不會轉型，<br>就以下範例來說，無論是與數值 0、與空字串、布林值 false，進行比較的時候，最終所獲得的結果都是 false。</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-number">0</span>);           <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-string">&#x27;&#x27;</span>);          <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">false</span>);       <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-number">0</span>);      <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-string">&#x27;&#x27;</span>);     <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">false</span>);  <span class="hljs-comment">// false</span></code></pre><p>有什麼口訣或技巧可以記嗎？<br><strong>當 null 與 undefined 只有在這兩者互相比較的時候結果為 true，其餘均為 false！！！</strong></p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span>);            <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// true</span></code></pre><h3 id="物件與非物件的寬鬆比較規則"><a href="#物件與非物件的寬鬆比較規則" class="headerlink" title="物件與非物件的寬鬆比較規則"></a><span style="color:white; background-color: #2a2936; padding: 5px">物件與非物件的寬鬆比較規則</span></h3><p>當物件與物件進行寬鬆比較時，會以「記憶體位址」來進行比較，所以得到的結果皆為 false。<br>不過當物件與其他原始型別進行寬鬆比較時，會產生不同的結果，這邊有一個很重要的概念是：「物件型別與其他型別進行比較時，會透過<u>包裹物件</u>將物件轉換成相同的型別後再進行比較」。</p><p>雖然都是提及物件，但是待會會用陣列當作範例。</p><ol><li><strong>陣列與數值型別進行比較</strong><br>當數值 10 與陣列 [10] 進行比較時，因為陣列屬於物件型別，因此會透過數值的 Number 包裹物件進行轉換，Number([10]) &#x3D; 10，轉換後的結果一樣為 10，所以比對結果為 true。</li></ol><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">10</span>] == <span class="hljs-number">10</span>);    <span class="hljs-comment">// true</span></code></pre><ol start="2"><li><strong>陣列與字串型別進行比較</strong><br>當陣列遇到字串型別時，會透過 String 包裹物件進行轉換，因此 [‘A’] 會轉為 ‘A’、[‘a’,’b’] 會轉為 ‘a,b’</li></ol><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-string">&#x27;A&#x27;</span>] == <span class="hljs-string">&#x27;A&#x27;</span>);    <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>] == <span class="hljs-string">&#x27;a,b&#x27;</span>);    <span class="hljs-comment">// true</span></code></pre><ol start="3"><li><strong>例外狀況：陣列與布林型別進行比較</strong><br>當布林值與陣列進行比較時，布林值會被 Number 包裹物件轉型成數值 1，<br>以及任何物件透過 Boolean 包裹物件進行轉型，都會得到 true 的結果。</li></ol><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>([]));                <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(&#123;&#125;));                <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125;));    <span class="hljs-comment">// true</span></code></pre><p>下面的比對會得到 false，</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] == <span class="hljs-literal">true</span>);                <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == <span class="hljs-literal">true</span>);                <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125; == <span class="hljs-literal">true</span>);    <span class="hljs-comment">// false</span></code></pre><p>這是因為 true 被轉型了，當布林值與陣列進行比較時，布林值會被 Number 包裹物件轉型成數值 1！<br>所以只有 [1] 才會得到 true，其他都會得到 false</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>] == <span class="hljs-literal">true</span>);             <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">2</span>] == <span class="hljs-literal">true</span>);             <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">3</span>] == <span class="hljs-literal">true</span>);             <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == <span class="hljs-literal">true</span>);              <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>)&#123;&#125; == <span class="hljs-literal">true</span>);  <span class="hljs-comment">// false</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 型別 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 型別 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>型別 2：原始型別的包裹物件 Primitive Wrapper Objects</title>
      <link href="/2024/07/20/%E5%9E%8B%E5%88%A5-2%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5%E5%8C%85%E8%A3%B9%E7%89%A9%E4%BB%B6/"/>
      <url>/2024/07/20/%E5%9E%8B%E5%88%A5-2%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5%E5%8C%85%E8%A3%B9%E7%89%A9%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>注意文章的標題是「原始型別的包裹物件」，<br>因此接下來講的內容，都跟「原始型別」有關，但是與 <code>null</code>，<code>undefined</code> 無關。( 因為它們兩個沒有包裹物件 )</p><h2 id="為什麼原始型別的值可以呼叫方法？"><a href="#為什麼原始型別的值可以呼叫方法？" class="headerlink" title="為什麼原始型別的值可以呼叫方法？"></a>為什麼原始型別的值可以呼叫方法？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>因為 JavaScript 會自動將原始型別的值，轉換成對應的「包裹物件」後，再呼叫物件中的方法。</p></blockquote><p>在探討包裹物件之前，可以先思考一個問題，<br>為什麼當你宣告一個 string 變數時，可以使用如下<code>toUpperCase()</code>的方法?</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;John&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// &quot;JOHN&quot;</span></code></pre><p><code>name</code> 明明是一個原始型別的變數，為什麼可以像物件呼叫方法的方式去呼叫 <code>toUpperCase()</code>？</p><p>這是因為當你嘗試在一個原始值上呼叫方法時，JavaScript 會自動將<code>name</code>變數轉換成對應的「包裹物件」，而這個過程稱為「裝箱」（boxing）。<br>裝箱的工作原理如下：</p><ol><li><strong>創建臨時物件</strong>：JavaScript 會創建一個臨時的包裹物件( 以上面的例子來說，會創建一個「字串包裹物件」 )，這個過程是隱式的。</li><li><strong>呼叫對應方法</strong>：創建臨時包裹物件後，JavaScript 會在這個臨時物件上呼叫對應的方法( 以上面的例子來說是 <code>toUpperCase()</code> 方法)。</li><li><strong>回傳結果</strong>：方法執行完畢後，回傳結果。</li><li><strong>銷毀臨時物件</strong>：立即銷毀這個臨時創建的包裹物件，不會影響原始值。</li></ol><h2 id="將包裹物件視覺化會長怎樣？"><a href="#將包裹物件視覺化會長怎樣？" class="headerlink" title="將包裹物件視覺化會長怎樣？"></a>將包裹物件視覺化會長怎樣？</h2><p>既然知道「原始值」在呼叫方法時，JS 會自動轉換成對應的「包裹物件」再去呼叫該方法，<br>也知道轉換的過程是隱式的，那如果用顯式的方式來觀察轉換的過程，看起來會像下面的這樣：</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;John&quot;</span>;<span class="hljs-keyword">let</span> newName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(name);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newName.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// &quot;JOHN&quot;</span><span class="hljs-comment">// 然後銷毀 newName</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// &quot;John&quot; (原本的 name 值不受影響)</span></code></pre><p>解釋：</p><ul><li>宣告一個 type 為字串的 name 變數</li><li>透過 new 運算子搭配字串的「包裹物件函式 String」將 name 轉換成「包裹物件」(實戰上不推薦這樣使用)</li><li>在「包裹物件」上呼叫 toUpperCase() 方法，並回傳結果</li></ul><h3 id="包裹物件與原始值的區別"><a href="#包裹物件與原始值的區別" class="headerlink" title="包裹物件與原始值的區別"></a>包裹物件與原始值的區別</h3><p>最大的區別當然是 type 啦</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;John&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> name); <span class="hljs-comment">// &quot;string&quot;</span><span class="hljs-keyword">let</span> newName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(name);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> newName); <span class="hljs-comment">// &quot;object&quot;</span></code></pre><h3 id="哪些原始值可以使用包裹物件函式"><a href="#哪些原始值可以使用包裹物件函式" class="headerlink" title="哪些原始值可以使用包裹物件函式"></a>哪些原始值可以使用包裹物件函式</h3><table><thead><tr><th>型別</th><th>包裹物件</th><th>使否可作為函式建構子使用</th></tr></thead><tbody><tr><td>字串 (String)</td><td>有包裹物件：String</td><td>是</td></tr><tr><td>數值 (Number)</td><td>有包裹物件：Number</td><td>是</td></tr><tr><td>布林 (Boolean)</td><td>有包裹物件：Boolean</td><td>是</td></tr><tr><td>BigInt</td><td>有包裹物件：BigInt</td><td>否</td></tr><tr><td>Symbol</td><td>有包裹物件：Symbol</td><td>否</td></tr><tr><td>undefined</td><td>無包裹物件</td><td>無</td></tr><tr><td>null</td><td>無包裹物件</td><td>無</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 型別 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 型別 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>型別 1：原始型別 &amp; 物件型別</title>
      <link href="/2024/07/14/%E5%9E%8B%E5%88%A5-1%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5/"/>
      <url>/2024/07/14/%E5%9E%8B%E5%88%A5-1%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-的型別"><a href="#JavaScript-的型別" class="headerlink" title="JavaScript 的型別"></a>JavaScript 的型別</h2><p>在 JavaScript 的世界裡，只有兩大型別，分別是 <strong>Primitive Type（原始型別）</strong>和 <strong>Object Type（物件型別）</strong>。</p><h4 id="原始型別的種類如下："><a href="#原始型別的種類如下：" class="headerlink" title="原始型別的種類如下："></a>原始型別的種類如下：</h4><ul><li>Boolean</li><li>Number</li><li>String</li><li>BigInt</li><li>Symbol</li><li>Null</li><li>Undefined</li></ul><h4 id="以下種類皆為物件型別："><a href="#以下種類皆為物件型別：" class="headerlink" title="以下種類皆為物件型別："></a>以下種類皆為物件型別：</h4><ul><li>Array</li><li>Object</li><li>Function</li></ul><p>除了原始型別以外，其餘都可以歸類在物件型別，例如陣列、物件、函式都屬於物件型別。</p><blockquote><p>JavaScript 共有 7 種 <strong>「原始型別</strong>，其餘的都屬於 <strong>「物件型別」</strong>。</p></blockquote><h2 id="如何區分原始型別與物件型別？"><a href="#如何區分原始型別與物件型別？" class="headerlink" title="如何區分原始型別與物件型別？"></a>如何區分原始型別與物件型別？</h2><h3 id="原始型別無法增加屬性，物件型別可以增加屬性"><a href="#原始型別無法增加屬性，物件型別可以增加屬性" class="headerlink" title="原始型別無法增加屬性，物件型別可以增加屬性"></a>原始型別無法增加屬性，物件型別可以增加屬性</h3><p>原始型別：</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> string = <span class="hljs-string">&quot;我是小明&quot;</span>;string.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;我是字串&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-property">name</span>); <span class="hljs-comment">// undefined，無法新增屬性</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string); <span class="hljs-comment">// 我是小明</span></code></pre><p>物件型別：</p><pre><code class="hljs JS"><span class="hljs-comment">// 對物件新增屬性</span><span class="hljs-keyword">let</span> object = &#123;  <span class="hljs-attr">property</span>: <span class="hljs-string">&quot;我是物件&quot;</span>,&#125;object.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;我是一個屬性&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;我是一個屬性&quot;</span><span class="hljs-comment">// 對陣列新增屬性（實戰中請不要對陣列這樣做)</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];arr.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;我是一個陣列&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;我是一個陣列&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<span class="hljs-comment">// [1, 2, 3, name: &#x27;我是一個陣列&#x27;]</span><span class="hljs-comment">// 對函式新增屬性（實戰中請不要對函式這樣做)</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;&#125;fn.<span class="hljs-property">myName</span> = <span class="hljs-string">&quot;我是一個函式&quot;</span>; <span class="hljs-comment">// 函式本身就有 name 屬性，別覆蓋它</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-property">myName</span>); <span class="hljs-comment">// &quot;我是一個函式&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(fn); <span class="hljs-comment">// 可以印出函式的結構</span></code></pre><h3 id="型別判斷方式"><a href="#型別判斷方式" class="headerlink" title="型別判斷方式"></a>型別判斷方式</h3><p>在大多數型別中，都可以透過 <code>typeof</code> 運算子來判別，是實戰中最常見用來判斷型別的手法，例如下方的一些例子：</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;這是一句話&quot;</span>); <span class="hljs-comment">// &quot;string&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>); <span class="hljs-comment">// &quot;number&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>); <span class="hljs-comment">// &quot;boolean&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;sym&quot;</span>)); <span class="hljs-comment">// &quot;symbol&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">100n</span>); <span class="hljs-comment">// &quot;bigint&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;object&quot;，null 會被判斷成 Object 型別，這是一個 JS 的 Bug，然後官方也不打算改( 因為會牽一髮動全身 )</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// &quot;undefined&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> []); <span class="hljs-comment">// &quot;object&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;); <span class="hljs-comment">// &quot;object&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;); <span class="hljs-comment">// &quot;function&quot;，雖然印出 function，但還是當作物件型別看待</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 型別 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 型別 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 6：undefined 與 null 的差異</title>
      <link href="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-6%EF%BC%9Aundefined-%E8%88%87-null-%E7%9A%84%E5%B7%AE%E7%95%B0-1/"/>
      <url>/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-6%EF%BC%9Aundefined-%E8%88%87-null-%E7%9A%84%E5%B7%AE%E7%95%B0-1/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在 Javascript 中有兩大型別，其中 <font color=#0000FF>undefined</font> 與 <font color=#0000FF>null</font> 都是屬於 <font color=#FF0000>Primitive value</font>( 原始值或稱基本型別 )，<br>而<strong>原始值是無法被更改的！</strong>，<br>例如 Boolean 只會有 true 和 false 這兩種值，因此 null 、undefined 也是一樣。<br>undefined 型別只有一種值，就是 <font color=#0000FF>undefined</font>。<br>null 型別只有一種值，就是 <font color=#0000FF>null</font>。</p><h3 id="undefined-的定義"><a href="#undefined-的定義" class="headerlink" title="undefined 的定義"></a>undefined 的定義</h3><p><font color=#0000FF>undefined</font> 表示一個變數已經被宣告，但是該變數的值尚未定義。<br>『undefined means a variable has been declared but has not yet been assigned a value 。』<br>例：</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> test;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test); <span class="hljs-comment">//shows undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> test); <span class="hljs-comment">//shows undefined</span></code></pre><h3 id="null-的定義"><a href="#null-的定義" class="headerlink" title="null 的定義"></a>null 的定義</h3><p><font color=#0000FF>null</font> 是一個值，可以被賦予到一個變數上，來表示該變數目前的值是空值。<br>『null is an assignment value. It can be assigned to a variable as a representation of no value』</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> test = <span class="hljs-literal">null</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test); <span class="hljs-comment">//shows undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> test); <span class="hljs-comment">//shows object</span><span class="hljs-comment">/*</span><span class="hljs-comment">  注意：</span><span class="hljs-comment">  變數目前的值是空值不等於變數目前的值為 0，</span><span class="hljs-comment">  空值 ≠ 0。</span><span class="hljs-comment">*/</span></code></pre><h3 id="從定義了解差異"><a href="#從定義了解差異" class="headerlink" title="從定義了解差異"></a>從定義了解差異</h3><p>從前面兩個程式碼的例子中可以發現，<font color=#0000FF>undefined</font> 和 <font color=#0000FF>null</font> 是兩種不同的型別</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false (not the same type)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true (but the &quot;same value&quot;)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> === <span class="hljs-literal">null</span>) <span class="hljs-comment">// true (both type and value are the same)</span></code></pre><table><thead><tr><th></th><th>undefined</th><th>null</th></tr></thead><tbody><tr><td>定義</td><td>表示某變數已經被宣告，但該變數的值<font color=#FF0000>尚未定義</font></td><td>變數的值<font color=#FF0000>已經定義</font>，值是 null，表示變數目前的值是空值</td></tr></tbody></table><h2 id="使用情境來理解差異"><a href="#使用情境來理解差異" class="headerlink" title="使用情境來理解差異"></a>使用情境來理解差異</h2><ul><li><strong><font color=#ffa500>name is undefined</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// name is undefined</span><span class="hljs-keyword">var</span> name;</code></pre><p>You: What is name?<br>JavaScript: name? What’s a name? I don’t know what you’re talking about. You haven’t ever mentioned any name before. Are you seeing some other scripting language on the client-side?</p><ul><li><strong><font color=#ffa500>name &#x3D; null</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-literal">null</span>;</code></pre><p>You: What is name?<br>JavaScript: I don’t</p><ul><li><strong><font color=#ffa500>name &#x3D; false</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-literal">false</span>;</code></pre><p>You: What is name?<br>JavaScript: Boolean false.</p><ul><li><strong><font color=#ffa500>name &#x3D; “”</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;&quot;</span>;</code></pre><p>You: What is name?<br>JavaScript: Empty string.</p><h2 id="一張圖理解差異"><a href="#一張圖理解差異" class="headerlink" title="一張圖理解差異"></a>一張圖理解差異</h2><p><img src="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-6%EF%BC%9Aundefined-%E8%88%87-null-%E7%9A%84%E5%B7%AE%E7%95%B0-1/image.png"></p><h2 id="undefined-可以當作變數名稱或參數使用"><a href="#undefined-可以當作變數名稱或參數使用" class="headerlink" title="undefined 可以當作變數名稱或參數使用"></a>undefined 可以當作變數名稱或參數使用</h2><p>驚不驚喜，意不意外～我們常說不能拿保留字當作變數，沒想到 undefined 居然打破這個限制！！！在非全域作用範圍下， undefined 允許被當成變數名稱，而且變數的值是可以被修改的。</p><pre><code class="hljs JS"><span class="hljs-comment">// 當作變數名稱</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`值為<span class="hljs-subst">$&#123;<span class="hljs-literal">undefined</span>&#125;</span>，型別為<span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>&#125;</span>`</span>); <span class="hljs-comment">// 顯示：值為foo，型別為string</span>&#125;)()<span class="hljs-comment">// 當作參數</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-literal">undefined</span></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`值為<span class="hljs-subst">$&#123;<span class="hljs-literal">undefined</span>&#125;</span>，型別為<span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>&#125;</span>`</span>); <span class="hljs-comment">// 顯示：值為foo，型別為string</span>&#125;)(<span class="hljs-string">&#x27;foo&#x27;</span>);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 5：undefined &amp; is not defined</title>
      <link href="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-5%EF%BC%9Aundefined-is-not-defined/"/>
      <url>/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-5%EF%BC%9Aundefined-is-not-defined/</url>
      
        <content type="html"><![CDATA[<h2 id="undefined-is-not-defined-兩者之間的差別？"><a href="#undefined-is-not-defined-兩者之間的差別？" class="headerlink" title="undefined &amp; is not defined 兩者之間的差別？"></a>undefined &amp; is not defined 兩者之間的差別？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>undefined 是一個變數尚未被賦予值的狀態。<br>「is not defined」是一個<font color=#FF0000>錯誤</font>訊息，會直接中斷程式碼執行。</p></blockquote><ul><li>is not defined 的例子</li></ul><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// Uncaught ReferenceError: myName is not defined</span></code></pre><ul><li>undefined 的例子</li></ul><pre><code class="hljs JS"><span class="hljs-number">1.</span>  <span class="hljs-keyword">var</span> myName;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-number">2.</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);  <span class="hljs-keyword">var</span> myName;<span class="hljs-number">3.</span>  <span class="hljs-keyword">var</span> person = &#123;&#125;;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// 印出物件中沒有的屬性也會顯示 undefined (避免程式直接中斷，算是一種保護機制)</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>.<span class="hljs-property">first</span>) <span class="hljs-comment">// 但是若想取得更深層的屬性，就會跳出下面的錯誤，</span>   <span class="hljs-comment">// Uncaught TypeError: Cannot read properties of undefined (reading &#x27;first&#x27;)</span>  <span class="hljs-comment">/*</span><span class="hljs-comment">  以下兩個例子可以檢視欲存取的屬性值在不在</span><span class="hljs-comment">  1.</span><span class="hljs-comment">    if(person.hasOwnProperty(&#x27;name&#x27;))&#123; // 如果有 name 這個屬性</span><span class="hljs-comment">    console.log(person.name.first);  // 才針對更深層的屬性取值</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">  2.</span><span class="hljs-comment">    console.log(person?.name?.first); // 可選串連，會取得 undefined 的結果，不會出錯</span><span class="hljs-comment">  */</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 4：TDZ</title>
      <link href="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%204%EF%BC%9ATDZ/"/>
      <url>/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%204%EF%BC%9ATDZ/</url>
      
        <content type="html"><![CDATA[<h2 id="什麼是-TDZ（Temporal-dead-zone）？"><a href="#什麼是-TDZ（Temporal-dead-zone）？" class="headerlink" title="什麼是 TDZ（Temporal dead zone）？"></a>什麼是 TDZ（Temporal dead zone）？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>意指 let 、const 宣告變數的「前方區域」，如果試圖在此區域取得值，則會出現 ReferenceError 的提示。</p></blockquote><p>在傳統的 var 宣告中，若是先取值再宣告並不會出錯，會出現「Undefined」。<br>但是在 let、const 宣告的情況下，先取值再宣告的話，會出現「Uncaught ReferenceError：Cannot access ‘xxx’ before initialization」(依瀏覽器版本可能出現不同訊息)，<br>也就是說 let、const 無法在初始化之前就取得該變數，因此開發者會很清楚不該這麼做~</p><blockquote><p>let、const 一樣有「提升」的概念，只是沒辦法存取裡面的值而已！<br>而 var 是出現「undefined」，可以存到值，只是值是 undefined。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 3：提升(Hoisting)</title>
      <link href="/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%203%EF%BC%9A%E6%8F%90%E5%8D%87(Hoisting)/"/>
      <url>/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%203%EF%BC%9A%E6%8F%90%E5%8D%87(Hoisting)/</url>
      
        <content type="html"><![CDATA[<h2 id="什麼是提升（Hoisting）？"><a href="#什麼是提升（Hoisting）？" class="headerlink" title="什麼是提升（Hoisting）？"></a>什麼是提升（Hoisting）？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>在 JavaScript 中先賦予變數或函式一個記憶體空間的這個機制，就稱為<strong>提升</strong>。</p></blockquote><h3 id="在這之前先來談創造階段與執行階段這兩個概念"><a href="#在這之前先來談創造階段與執行階段這兩個概念" class="headerlink" title="在這之前先來談創造階段與執行階段這兩個概念"></a>在這之前先來談創造階段與執行階段這兩個概念</h3><ul><li>創造階段（Creation）：瀏覽器為變數或是函式創造記憶體空間的階段。</li><li>執行階段（Execution）：瀏覽器將「值」賦予變數的階段。</li></ul><ol><li>先以下列程式碼為例子</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">//印出小白</span><span class="hljs-comment">/*</span><span class="hljs-comment">    解釋上述程式碼的 創造階段 與 執行階段</span><span class="hljs-comment">    1. 創造階段：myName 變數「提升」，獲得一個記憶體空間，其值是 undefined</span><span class="hljs-comment">    2. 執行階段：myName 變數被賦予值，其值是&#x27;小白&#x27;，console.log(myName) 會將 myName 變數中的值取出來後印出來</span><span class="hljs-comment">*/</span></code></pre><ol start="2"><li>修改一下順序</li></ol><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">// console.log 會印出 undefined，而不是 Uncaught ReferenceError: myName is not defined 的錯誤。</span><span class="hljs-comment">/*</span><span class="hljs-comment">  為什麼不會印出錯誤？myName 變數不是後面才宣告嗎？原因是因為 myName 變數「提升」了！</span><span class="hljs-comment">  在印出來之前，myName 變數已經有了記憶體空間，只是還沒被賦予值，因此是 undefined。</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">  1. 創造階段：myName 變數「提升」，獲得一個記憶體空間，其值是 undefined</span><span class="hljs-comment">  2. 執行階段：console.log(myName) 將 myName 變數中的值印出來 ( 先印出 undefined )</span><span class="hljs-comment">              然後 myName 變數才被賦予 &#x27;小白&#x27; 這個值。</span><span class="hljs-comment">*/</span></code></pre><blockquote><p>有了提升的概念之後，在來要討論的是，函式提升與變數提升的不同處。</p></blockquote><h2 id="函式的創造階段與執行階段，與變數相比多了兩個原則："><a href="#函式的創造階段與執行階段，與變數相比多了兩個原則：" class="headerlink" title="函式的創造階段與執行階段，與變數相比多了兩個原則："></a>函式的創造階段與執行階段，與變數相比多了兩個原則：</h2><ul><li>函式在創造階段就已經有完整的記憶體空間</li><li><strong>函式陳述式</strong>優先函式表達式與變數宣告</li></ul><ol><li>舉例</li></ol><pre><code class="hljs JS"><span class="hljs-title function_">callName</span>();<span class="hljs-comment">/*</span><span class="hljs-comment">  callName 函式在比較下面，理論上應該是沒辦法成功執行 callName()，</span><span class="hljs-comment">  但是因為「提升」的機制，使得 callName 函式優先獲得記憶體空間，因此你要在哪裡呼叫都可以</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 下行函式的宣告方式叫做「函式陳述式」</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">callName</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是小明&#x27;</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    解釋上述程式碼的創造階段與執行階段</span><span class="hljs-comment">    1. 創造階段：callName 函式陳述式優先「提升」，獲得一個記憶體空間</span><span class="hljs-comment">    2. 執行階段：呼叫了 callName() 函式，印出&#x27;我是小明&#x27;</span><span class="hljs-comment">*/</span></code></pre><ol start="2"><li>函式陳述式 v.s 函式表達式 ⇒ 兩者之間的差異在於「提升的方式」不同</li></ol><pre><code class="hljs JS"><span class="hljs-comment">//函式陳述式</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;這是函式陳述式&#x27;</span>);&#125;<span class="hljs-comment">//函式表達式</span><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;這是函式表達式&#x27;</span>);&#125;<span class="hljs-title function_">fn</span>();<span class="hljs-comment">//呼叫 fn 函式，會印出 &#x27;這是函式陳述式&#x27; 還是 &#x27;這是函式表達式呢&#x27;？</span><span class="hljs-comment">/*</span><span class="hljs-comment">    這邊開始解釋「函式陳述式」與「函式表達式」的不同處，</span><span class="hljs-comment">    以上述程式碼為例，列出創造階段與執行階段</span><span class="hljs-comment"></span><span class="hljs-comment">    1. 創造階段：</span><span class="hljs-comment">        function fn()&#123; //函式陳述式優先提升</span><span class="hljs-comment">          console.log(&#x27;這是函式陳述式&#x27;);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        var fn; //fn 變數提升</span><span class="hljs-comment"></span><span class="hljs-comment">    2. 執行階段：</span><span class="hljs-comment">        fn = function()&#123; // fn 被賦予值</span><span class="hljs-comment">          console.log(&#x27;這是函式表達式&#x27;);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        fn(); //呼叫 fn 函式，最終印出&#x27;這是函式表達式&#x27;！！</span><span class="hljs-comment"></span><span class="hljs-comment">    不同之處在於函式表達式會在執行階段才將值(整個function) assign 給 fn 變數，</span><span class="hljs-comment">    進而覆蓋了在創造階段出現的函式陳述式，所以才會印出&#x27;函式表達式&#x27;。</span><span class="hljs-comment">*/</span></code></pre><p>第一次理解 Hoisting 時有點小吃力，<br>不過大腦是一個神奇的東西，隨著時間拉長再回頭看，就知道這是什麼了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 2：變數作用域的範圍</title>
      <link href="/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%202%EF%BC%9A%E8%AE%8A%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%AF%84%E5%9C%8D/"/>
      <url>/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%202%EF%BC%9A%E8%AE%8A%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%AF%84%E5%9C%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="var、let、const-三者宣告出來的變數作用域差別為何？"><a href="#var、let、const-三者宣告出來的變數作用域差別為何？" class="headerlink" title="var、let、const 三者宣告出來的變數作用域差別為何？"></a>var、let、const 三者宣告出來的變數作用域差別為何？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>var 的作用域範圍在函式內( 所以又稱函式作用域 )，let、const 則屬於區塊作用域，且目前主流的宣告方式皆採用 let、const。</p></blockquote><p>等等，什麼是函式作用域？什麼是區塊作用域？</p><h3 id="函式作用域"><a href="#函式作用域" class="headerlink" title="函式作用域"></a>函式作用域</h3><p>函式作用域的意思就是，變數的生命週期在一個函式內，然後樣子看來起來像這樣：</p><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;    <span class="hljs-comment">// myName 的生命週期僅存在此函式中</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);&#125;<span class="hljs-title function_">fn</span>();<span class="hljs-comment">//印出小白</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// Uncaught ReferenceError: myName is not defined</span></code></pre><h3 id="區塊作用域"><a href="#區塊作用域" class="headerlink" title="區塊作用域"></a>區塊作用域</h3><p>區塊作用域則有下列幾種類型</p><ul><li>函式：function fn() { …… } 區塊作用域是函式作用域的一種</li><li>for 迴圈：for( xxx）{ …… }</li><li>判斷式：if( expression ){ …… }</li><li>純粹的區塊：｛｝</li><li>基本上看到｛｝都可以認定為一個區塊</li></ul><h3 id="好像還看不太出來差別，用以下例子區分"><a href="#好像還看不太出來差別，用以下例子區分" class="headerlink" title="好像還看不太出來差別，用以下例子區分"></a>好像還看不太出來差別，用以下例子區分</h3><ul><li>for 迴圈</li></ul><pre><code class="hljs JS"><span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span>; i++ )&#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<span class="hljs-comment">// 印出 10，抓得到 i 這個值！！</span><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span> ; j&lt;<span class="hljs-number">10</span>; j++ )&#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<span class="hljs-comment">// 印出 Uncaught ReferenceError: j is not defined</span></code></pre><ul><li>for 迴圈</li></ul><pre><code class="hljs JS"><span class="hljs-keyword">if</span>( ..... )&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// 印出小白</span><span class="hljs-keyword">if</span>( ..... )&#123;    <span class="hljs-keyword">let</span> yourName = <span class="hljs-string">&#x27;小葵&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(yourName);<span class="hljs-comment">// 印出 Uncaught ReferenceError: yourName is not defined</span></code></pre><ul><li>純粹的區塊</li></ul><pre><code class="hljs JS">&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// 印出小白</span>&#123;    <span class="hljs-keyword">let</span> yourName = <span class="hljs-string">&#x27;小葵&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(yourName);<span class="hljs-comment">// 印出 Uncaught ReferenceError: yourName is not defined</span></code></pre><p>從上述三個例子中可以發現，<br>區塊作用域的優點會比函式作用域的優點要來得多，<br>因為 var 所宣告的變數，除了在函式中宣告的不會變成全域變數外，其餘都會變成全域變數，<br>這在幾百行幾千行中是非常難以除錯的，因此 let、const 宣告詞才會成為主流。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 1：全域變數 &amp; 全域屬性</title>
      <link href="/2024/07/12/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%201%EF%BC%9A%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8%20&amp;%20%E5%85%A8%E5%9F%9F%E5%B1%AC%E6%80%A7/"/>
      <url>/2024/07/12/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%201%EF%BC%9A%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8%20&amp;%20%E5%85%A8%E5%9F%9F%E5%B1%AC%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="為什麼變數需要宣告？能不宣告直接用嗎？"><a href="#為什麼變數需要宣告？能不宣告直接用嗎？" class="headerlink" title="為什麼變數需要宣告？能不宣告直接用嗎？"></a>為什麼變數需要宣告？能不宣告直接用嗎？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>沒有透過「宣告」產生出來的變數，會是一個「全域的 windows 物件底下的一個屬性」。</p></blockquote><p>變數如果不透過 var、let 、const 宣告的話，會變成一個名為 windwos 物件底下的一個屬性，<br>該屬性是一個全域屬性！<br>範例：</p><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">// 注意，a 變數並沒有透過 var、let、const 來宣告，</span>    <span class="hljs-comment">// 卻可以被底下的 fn2() 所使用</span>    a = <span class="hljs-string">&#x27;小明&#x27;</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>)<span class="hljs-comment">// 實際上這個 a 變數是 winsows 物件下的一個屬性</span>&#125;<span class="hljs-title function_">fn1</span>(); <span class="hljs-comment">// 呼叫 fn1()，產生一個具全域屬性 a</span><span class="hljs-title function_">fn2</span>(); <span class="hljs-comment">// 呼叫 fn2()，印出兩次小明</span></code></pre><p>這種沒有透過「宣告」的方式所產生出來的變數，會因為是一個全域屬性的關係，容易被汙染，進而難以 debug。</p><h2 id="那變數與屬性的差異為何？"><a href="#那變數與屬性的差異為何？" class="headerlink" title="那變數與屬性的差異為何？"></a>那變數與屬性的差異為何？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>差異就是只有「屬性」才可以使用 delete 運算子刪除 。</p></blockquote><p>範例：</p><pre><code class="hljs JS">a = <span class="hljs-string">&#x27;小白&#x27;</span>; <span class="hljs-comment">//因為沒有用宣告字，所以會在 windows 物件底下會新增一個屬性叫做 a</span><span class="hljs-keyword">delete</span> a; <span class="hljs-comment">// a 是一個全域屬性，可透過 delete 刪除</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>); <span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span></code></pre><pre><code class="hljs JS"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;小白&#x27;</span>; <span class="hljs-comment">// 雖然是用「宣告的方式」，但 windows 物件底下還是會新增一個屬性叫做 a，</span>                <span class="hljs-comment">// 但透過「宣告的方式」所產生出來的屬性是無法利用 delete 運算子刪除的</span><span class="hljs-keyword">delete</span> a; <span class="hljs-comment">// 無法透過 delete 刪除</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>); <span class="hljs-comment">//印出小白</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 印出小白</span></code></pre><p>沒使用宣告字宣告的變數 -&gt; 全域屬性，可用 delete 運算子刪除此屬性。<br>使用 var 宣告字宣告的變數 -&gt; 全域變數，無法使用 delete 運算子刪除。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/07/12/hello-world/"/>
      <url>/2024/07/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
