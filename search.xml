<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>變數與作用域 6：undefined 與 null 的差異</title>
      <link href="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-6%EF%BC%9Aundefined-%E8%88%87-null-%E7%9A%84%E5%B7%AE%E7%95%B0-1/"/>
      <url>/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-6%EF%BC%9Aundefined-%E8%88%87-null-%E7%9A%84%E5%B7%AE%E7%95%B0-1/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在 Javascript 中有兩大型別，其中 <font color=#0000FF>undefined</font> 與 <font color=#0000FF>null</font> 都是屬於 <font color=#FF0000>Primitive value</font>( 原始值或稱基本型別 )，<br>而<strong>原始值是無法被更改的！</strong>，<br>例如 Boolean 只會有 true 和 false 這兩種值，因此 null 、undefined 也是一樣。<br>undefined 型別只有一種值，就是 <font color=#0000FF>undefined</font>。<br>null 型別只有一種值，就是 <font color=#0000FF>null</font>。</p><h3 id="undefined-的定義"><a href="#undefined-的定義" class="headerlink" title="undefined 的定義"></a>undefined 的定義</h3><p><font color=#0000FF>undefined</font> 表示一個變數已經被宣告，但是該變數的值尚未定義。<br>『undefined means a variable has been declared but has not yet been assigned a value 。』<br>例：</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> test;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test); <span class="hljs-comment">//shows undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> test); <span class="hljs-comment">//shows undefined</span></code></pre><h3 id="null-的定義"><a href="#null-的定義" class="headerlink" title="null 的定義"></a>null 的定義</h3><p><font color=#0000FF>null</font> 是一個值，可以被賦予到一個變數上，來表示該變數目前的值是空值。<br>『null is an assignment value. It can be assigned to a variable as a representation of no value』</p><pre><code class="hljs JS"><span class="hljs-keyword">let</span> test = <span class="hljs-literal">null</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test); <span class="hljs-comment">//shows undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> test); <span class="hljs-comment">//shows object</span><span class="hljs-comment">/*</span><span class="hljs-comment">  注意：</span><span class="hljs-comment">  變數目前的值是空值不等於變數目前的值為 0，</span><span class="hljs-comment">  空值 ≠ 0。</span><span class="hljs-comment">*/</span></code></pre><h3 id="從定義了解差異"><a href="#從定義了解差異" class="headerlink" title="從定義了解差異"></a>從定義了解差異</h3><p>從前面兩個程式碼的例子中可以發現，<font color=#0000FF>undefined</font> 和 <font color=#0000FF>null</font> 是兩種不同的型別</p><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false (not the same type)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true (but the &quot;same value&quot;)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> === <span class="hljs-literal">null</span>) <span class="hljs-comment">// true (both type and value are the same)</span></code></pre><table><thead><tr><th></th><th>undefined</th><th>null</th></tr></thead><tbody><tr><td>定義</td><td>表示某變數已經被宣告，但該變數的值<font color=#FF0000>尚未定義</font></td><td>變數的值<font color=#FF0000>已經定義</font>，值是 null，表示變數目前的值是空值</td></tr></tbody></table><h2 id="使用情境來理解差異"><a href="#使用情境來理解差異" class="headerlink" title="使用情境來理解差異"></a>使用情境來理解差異</h2><ul><li><strong><font color=#ffa500>name is undefined</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// name is undefined</span><span class="hljs-keyword">var</span> name;</code></pre><p>You: What is name?<br>JavaScript: name? What’s a name? I don’t know what you’re talking about. You haven’t ever mentioned any name before. Are you seeing some other scripting language on the client-side?</p><ul><li><strong><font color=#ffa500>name &#x3D; null</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-literal">null</span>;</code></pre><p>You: What is name?<br>JavaScript: I don’t</p><ul><li><strong><font color=#ffa500>name &#x3D; false</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-literal">false</span>;</code></pre><p>You: What is name?<br>JavaScript: Boolean false.</p><ul><li><strong><font color=#ffa500>name &#x3D; “”</font></strong></li></ul><pre><code class="hljs JS"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;&quot;</span>;</code></pre><p>You: What is name?<br>JavaScript: Empty string.</p><h2 id="一張圖理解差異"><a href="#一張圖理解差異" class="headerlink" title="一張圖理解差異"></a>一張圖理解差異</h2><p><img src="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-6%EF%BC%9Aundefined-%E8%88%87-null-%E7%9A%84%E5%B7%AE%E7%95%B0-1/image.png"></p><h2 id="undefined-可以當作變數名稱或參數使用"><a href="#undefined-可以當作變數名稱或參數使用" class="headerlink" title="undefined 可以當作變數名稱或參數使用"></a>undefined 可以當作變數名稱或參數使用</h2><p>驚不驚喜，意不意外～我們常說不能拿保留字當作變數，沒想到 undefined 居然打破這個限制！！！在非全域作用範圍下， undefined 允許被當成變數名稱，而且變數的值是可以被修改的。</p><pre><code class="hljs JS"><span class="hljs-comment">// 當作變數名稱</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`值為<span class="hljs-subst">$&#123;<span class="hljs-literal">undefined</span>&#125;</span>，型別為<span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>&#125;</span>`</span>); <span class="hljs-comment">// 顯示：值為foo，型別為string</span>&#125;)()<span class="hljs-comment">// 當作參數</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-literal">undefined</span></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`值為<span class="hljs-subst">$&#123;<span class="hljs-literal">undefined</span>&#125;</span>，型別為<span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>&#125;</span>`</span>); <span class="hljs-comment">// 顯示：值為foo，型別為string</span>&#125;)(<span class="hljs-string">&#x27;foo&#x27;</span>);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 5：undefined &amp; is not defined</title>
      <link href="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-5%EF%BC%9Aundefined-is-not-defined/"/>
      <url>/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F-5%EF%BC%9Aundefined-is-not-defined/</url>
      
        <content type="html"><![CDATA[<h2 id="undefined-is-not-defined-兩者之間的差別？"><a href="#undefined-is-not-defined-兩者之間的差別？" class="headerlink" title="undefined &amp; is not defined 兩者之間的差別？"></a>undefined &amp; is not defined 兩者之間的差別？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>undefined 是一個變數尚未被賦予值的狀態。<br>「is not defined」是一個<font color=#FF0000>錯誤</font>訊息，會直接中斷程式碼執行。</p></blockquote><ul><li>is not defined 的例子</li></ul><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// Uncaught ReferenceError: myName is not defined</span></code></pre><ul><li>undefined 的例子</li></ul><pre><code class="hljs JS"><span class="hljs-number">1.</span>  <span class="hljs-keyword">var</span> myName;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-number">2.</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);  <span class="hljs-keyword">var</span> myName;<span class="hljs-number">3.</span>  <span class="hljs-keyword">var</span> person = &#123;&#125;;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// 印出物件中沒有的屬性也會顯示 undefined (避免程式直接中斷，算是一種保護機制)</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>.<span class="hljs-property">first</span>) <span class="hljs-comment">// 但是若想取得更深層的屬性，就會跳出下面的錯誤，</span>   <span class="hljs-comment">// Uncaught TypeError: Cannot read properties of undefined (reading &#x27;first&#x27;)</span>  <span class="hljs-comment">/*</span><span class="hljs-comment">  以下兩個例子可以檢視欲存取的屬性值在不在</span><span class="hljs-comment">  1.</span><span class="hljs-comment">    if(person.hasOwnProperty(&#x27;name&#x27;))&#123; // 如果有 name 這個屬性</span><span class="hljs-comment">    console.log(person.name.first);  // 才針對更深層的屬性取值</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">  2.</span><span class="hljs-comment">    console.log(person?.name?.first); // 可選串連，會取得 undefined 的結果，不會出錯</span><span class="hljs-comment">  */</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 4：TDZ</title>
      <link href="/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%204%EF%BC%9ATDZ/"/>
      <url>/2024/07/14/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%204%EF%BC%9ATDZ/</url>
      
        <content type="html"><![CDATA[<h2 id="什麼是-TDZ（Temporal-dead-zone）？"><a href="#什麼是-TDZ（Temporal-dead-zone）？" class="headerlink" title="什麼是 TDZ（Temporal dead zone）？"></a>什麼是 TDZ（Temporal dead zone）？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>意指 let 、const 宣告變數的「前方區域」，如果試圖在此區域取得值，則會出現 ReferenceError 的提示。</p></blockquote><p>在傳統的 var 宣告中，若是先取值再宣告並不會出錯，會出現「Undefined」。<br>但是在 let、const 宣告的情況下，先取值再宣告的話，會出現「Uncaught ReferenceError：Cannot access ‘xxx’ before initialization」(依瀏覽器版本可能出現不同訊息)，<br>也就是說 let、const 無法在初始化之前就取得該變數，因此開發者會很清楚不該這麼做~</p><blockquote><p>let、const 一樣有「提升」的概念，只是沒辦法存取裡面的值而已！<br>而 var 是出現「undefined」，可以存到值，只是值是 undefined。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 3：提升(Hoisting)</title>
      <link href="/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%203%EF%BC%9A%E6%8F%90%E5%8D%87(Hoisting)/"/>
      <url>/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%203%EF%BC%9A%E6%8F%90%E5%8D%87(Hoisting)/</url>
      
        <content type="html"><![CDATA[<h2 id="什麼是提升（Hoisting）？"><a href="#什麼是提升（Hoisting）？" class="headerlink" title="什麼是提升（Hoisting）？"></a>什麼是提升（Hoisting）？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>在 JavaScript 中先賦予變數或函式一個記憶體空間的這個機制，就稱為<strong>提升</strong>。</p></blockquote><h3 id="在這之前先來談創造階段與執行階段這兩個概念"><a href="#在這之前先來談創造階段與執行階段這兩個概念" class="headerlink" title="在這之前先來談創造階段與執行階段這兩個概念"></a>在這之前先來談創造階段與執行階段這兩個概念</h3><ul><li>創造階段（Creation）：瀏覽器為變數或是函式創造記憶體空間的階段。</li><li>執行階段（Execution）：瀏覽器將「值」賦予變數的階段。</li></ul><ol><li>先以下列程式碼為例子</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">//印出小白</span><span class="hljs-comment">/*</span><span class="hljs-comment">    解釋上述程式碼的 創造階段 與 執行階段</span><span class="hljs-comment">    1. 創造階段：myName 變數「提升」，獲得一個記憶體空間，其值是 undefined</span><span class="hljs-comment">    2. 執行階段：myName 變數被賦予值，其值是&#x27;小白&#x27;，console.log(myName) 會將 myName 變數中的值取出來後印出來</span><span class="hljs-comment">*/</span></code></pre><ol start="2"><li>修改一下順序</li></ol><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">// console.log 會印出 undefined，而不是 Uncaught ReferenceError: myName is not defined 的錯誤。</span><span class="hljs-comment">/*</span><span class="hljs-comment">  為什麼不會印出錯誤？myName 變數不是後面才宣告嗎？原因是因為 myName 變數「提升」了！</span><span class="hljs-comment">  在印出來之前，myName 變數已經有了記憶體空間，只是還沒被賦予值，因此是 undefined。</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">  1. 創造階段：myName 變數「提升」，獲得一個記憶體空間，其值是 undefined</span><span class="hljs-comment">  2. 執行階段：console.log(myName) 將 myName 變數中的值印出來 ( 先印出 undefined )</span><span class="hljs-comment">              然後 myName 變數才被賦予 &#x27;小白&#x27; 這個值。</span><span class="hljs-comment">*/</span></code></pre><blockquote><p>有了提升的概念之後，在來要討論的是，函式提升與變數提升的不同處。</p></blockquote><h2 id="函式的創造階段與執行階段，與變數相比多了兩個原則："><a href="#函式的創造階段與執行階段，與變數相比多了兩個原則：" class="headerlink" title="函式的創造階段與執行階段，與變數相比多了兩個原則："></a>函式的創造階段與執行階段，與變數相比多了兩個原則：</h2><ul><li>函式在創造階段就已經有完整的記憶體空間</li><li><strong>函式陳述式</strong>優先函式表達式與變數宣告</li></ul><ol><li>舉例</li></ol><pre><code class="hljs JS"><span class="hljs-title function_">callName</span>();<span class="hljs-comment">/*</span><span class="hljs-comment">  callName 函式在比較下面，理論上應該是沒辦法成功執行 callName()，</span><span class="hljs-comment">  但是因為「提升」的機制，使得 callName 函式優先獲得記憶體空間，因此你要在哪裡呼叫都可以</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 下行函式的宣告方式叫做「函式陳述式」</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">callName</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是小明&#x27;</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    解釋上述程式碼的創造階段與執行階段</span><span class="hljs-comment">    1. 創造階段：callName 函式陳述式優先「提升」，獲得一個記憶體空間</span><span class="hljs-comment">    2. 執行階段：呼叫了 callName() 函式，印出&#x27;我是小明&#x27;</span><span class="hljs-comment">*/</span></code></pre><ol start="2"><li>函式陳述式 v.s 函式表達式 ⇒ 兩者之間的差異在於「提升的方式」不同</li></ol><pre><code class="hljs JS"><span class="hljs-comment">//函式陳述式</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;這是函式陳述式&#x27;</span>);&#125;<span class="hljs-comment">//函式表達式</span><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;這是函式表達式&#x27;</span>);&#125;<span class="hljs-title function_">fn</span>();<span class="hljs-comment">//呼叫 fn 函式，會印出 &#x27;這是函式陳述式&#x27; 還是 &#x27;這是函式表達式呢&#x27;？</span><span class="hljs-comment">/*</span><span class="hljs-comment">    這邊開始解釋「函式陳述式」與「函式表達式」的不同處，</span><span class="hljs-comment">    以上述程式碼為例，列出創造階段與執行階段</span><span class="hljs-comment"></span><span class="hljs-comment">    1. 創造階段：</span><span class="hljs-comment">        function fn()&#123; //函式陳述式優先提升</span><span class="hljs-comment">          console.log(&#x27;這是函式陳述式&#x27;);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        var fn; //fn 變數提升</span><span class="hljs-comment"></span><span class="hljs-comment">    2. 執行階段：</span><span class="hljs-comment">        fn = function()&#123; // fn 被賦予值</span><span class="hljs-comment">          console.log(&#x27;這是函式表達式&#x27;);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        fn(); //呼叫 fn 函式，最終印出&#x27;這是函式表達式&#x27;！！</span><span class="hljs-comment"></span><span class="hljs-comment">    不同之處在於函式表達式會在執行階段才將值(整個function) assign 給 fn 變數，</span><span class="hljs-comment">    進而覆蓋了在創造階段出現的函式陳述式，所以才會印出&#x27;函式表達式&#x27;。</span><span class="hljs-comment">*/</span></code></pre><p>第一次理解 Hoisting 時有點小吃力，<br>不過大腦是一個神奇的東西，隨著時間拉長再回頭看，就知道這是什麼了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 2：變數作用域的範圍</title>
      <link href="/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%202%EF%BC%9A%E8%AE%8A%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%AF%84%E5%9C%8D/"/>
      <url>/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%202%EF%BC%9A%E8%AE%8A%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%AF%84%E5%9C%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="var、let、const-三者宣告出來的變數作用域差別為何？"><a href="#var、let、const-三者宣告出來的變數作用域差別為何？" class="headerlink" title="var、let、const 三者宣告出來的變數作用域差別為何？"></a>var、let、const 三者宣告出來的變數作用域差別為何？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>var 的作用域範圍在函式內( 所以又稱函式作用域 )，let、const 則屬於區塊作用域，且目前主流的宣告方式皆採用 let、const。</p></blockquote><p>等等，什麼是函式作用域？什麼是區塊作用域？</p><h3 id="函式作用域"><a href="#函式作用域" class="headerlink" title="函式作用域"></a>函式作用域</h3><p>函式作用域的意思就是，變數的生命週期在一個函式內，然後樣子看來起來像這樣：</p><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;    <span class="hljs-comment">// myName 的生命週期僅存在此函式中</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);&#125;<span class="hljs-title function_">fn</span>();<span class="hljs-comment">//印出小白</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// Uncaught ReferenceError: myName is not defined</span></code></pre><h3 id="區塊作用域"><a href="#區塊作用域" class="headerlink" title="區塊作用域"></a>區塊作用域</h3><p>區塊作用域則有下列幾種類型</p><ul><li>函式：function fn() { …… } 區塊作用域是函式作用域的一種</li><li>for 迴圈：for( xxx）{ …… }</li><li>判斷式：if( expression ){ …… }</li><li>純粹的區塊：｛｝</li><li>基本上看到｛｝都可以認定為一個區塊</li></ul><h3 id="好像還看不太出來差別，用以下例子區分"><a href="#好像還看不太出來差別，用以下例子區分" class="headerlink" title="好像還看不太出來差別，用以下例子區分"></a>好像還看不太出來差別，用以下例子區分</h3><ul><li>for 迴圈</li></ul><pre><code class="hljs JS"><span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span>; i++ )&#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<span class="hljs-comment">// 印出 10，抓得到 i 這個值！！</span><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span> ; j&lt;<span class="hljs-number">10</span>; j++ )&#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<span class="hljs-comment">// 印出 Uncaught ReferenceError: j is not defined</span></code></pre><ul><li>for 迴圈</li></ul><pre><code class="hljs JS"><span class="hljs-keyword">if</span>( ..... )&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// 印出小白</span><span class="hljs-keyword">if</span>( ..... )&#123;    <span class="hljs-keyword">let</span> yourName = <span class="hljs-string">&#x27;小葵&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(yourName);<span class="hljs-comment">// 印出 Uncaught ReferenceError: yourName is not defined</span></code></pre><ul><li>純粹的區塊</li></ul><pre><code class="hljs JS">&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// 印出小白</span>&#123;    <span class="hljs-keyword">let</span> yourName = <span class="hljs-string">&#x27;小葵&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(yourName);<span class="hljs-comment">// 印出 Uncaught ReferenceError: yourName is not defined</span></code></pre><p>從上述三個例子中可以發現，<br>區塊作用域的優點會比函式作用域的優點要來得多，<br>因為 var 所宣告的變數，除了在函式中宣告的不會變成全域變數外，其餘都會變成全域變數，<br>這在幾百行幾千行中是非常難以除錯的，因此 let、const 宣告詞才會成為主流。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 1：全域變數 &amp; 全域屬性</title>
      <link href="/2024/07/12/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%201%EF%BC%9A%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8%20&amp;%20%E5%85%A8%E5%9F%9F%E5%B1%AC%E6%80%A7/"/>
      <url>/2024/07/12/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%201%EF%BC%9A%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8%20&amp;%20%E5%85%A8%E5%9F%9F%E5%B1%AC%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="為什麼變數需要宣告？能不宣告直接用嗎？"><a href="#為什麼變數需要宣告？能不宣告直接用嗎？" class="headerlink" title="為什麼變數需要宣告？能不宣告直接用嗎？"></a>為什麼變數需要宣告？能不宣告直接用嗎？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>沒有透過「宣告」產生出來的變數，會是一個「全域的 windows 物件底下的一個屬性」。</p></blockquote><p>變數如果不透過 var、let 、const 宣告的話，會變成一個名為 windwos 物件底下的一個屬性，<br>該屬性是一個全域屬性！<br>範例：</p><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">// 注意，a 變數並沒有透過 var、let、const 來宣告，</span>    <span class="hljs-comment">// 卻可以被底下的 fn2() 所使用</span>    a = <span class="hljs-string">&#x27;小明&#x27;</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>)<span class="hljs-comment">// 實際上這個 a 變數是 winsows 物件下的一個屬性</span>&#125;<span class="hljs-title function_">fn1</span>(); <span class="hljs-comment">// 呼叫 fn1()，產生一個具全域屬性 a</span><span class="hljs-title function_">fn2</span>(); <span class="hljs-comment">// 呼叫 fn2()，印出兩次小明</span></code></pre><p>這種沒有透過「宣告」的方式所產生出來的變數，會因為是一個全域屬性的關係，容易被汙染，進而難以 debug。</p><h2 id="那變數與屬性的差異為何？"><a href="#那變數與屬性的差異為何？" class="headerlink" title="那變數與屬性的差異為何？"></a>那變數與屬性的差異為何？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>差異就是只有「屬性」才可以使用 delete 運算子刪除 。</p></blockquote><p>範例：</p><pre><code class="hljs JS">a = <span class="hljs-string">&#x27;小白&#x27;</span>; <span class="hljs-comment">//因為沒有用宣告字，所以會在 windows 物件底下會新增一個屬性叫做 a</span><span class="hljs-keyword">delete</span> a; <span class="hljs-comment">// a 是一個全域屬性，可透過 delete 刪除</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>); <span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span></code></pre><pre><code class="hljs JS"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;小白&#x27;</span>; <span class="hljs-comment">// 雖然是用「宣告的方式」，但 windows 物件底下還是會新增一個屬性叫做 a，</span>                <span class="hljs-comment">// 但透過「宣告的方式」所產生出來的屬性是無法利用 delete 運算子刪除的</span><span class="hljs-keyword">delete</span> a; <span class="hljs-comment">// 無法透過 delete 刪除</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>); <span class="hljs-comment">//印出小白</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 印出小白</span></code></pre><p>沒使用宣告字宣告的變數 -&gt; 全域屬性，可用 delete 運算子刪除此屬性。<br>使用 var 宣告字宣告的變數 -&gt; 全域變數，無法使用 delete 運算子刪除。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 變數與作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/07/12/hello-world/"/>
      <url>/2024/07/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
