<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>變數與作用域 3：提升(Hoisting)</title>
      <link href="/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%203%EF%BC%9A%E6%8F%90%E5%8D%87(Hoisting)/"/>
      <url>/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%203%EF%BC%9A%E6%8F%90%E5%8D%87(Hoisting)/</url>
      
        <content type="html"><![CDATA[<h2 id="什麼是提升（Hoisting）？"><a href="#什麼是提升（Hoisting）？" class="headerlink" title="什麼是提升（Hoisting）？"></a>什麼是提升（Hoisting）？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>在 JavaScript 中先賦予變數或函式一個記憶體空間的這個機制，就稱為<strong>提升</strong>。</p></blockquote><h3 id="在這之前先來談創造階段與執行階段這兩個概念"><a href="#在這之前先來談創造階段與執行階段這兩個概念" class="headerlink" title="在這之前先來談創造階段與執行階段這兩個概念"></a>在這之前先來談創造階段與執行階段這兩個概念</h3><ul><li>創造階段（Creation）：瀏覽器為變數或是函式創造記憶體空間的階段。</li><li>執行階段（Execution）：瀏覽器將「值」賦予變數的階段。</li></ul><ol><li>先以下列程式碼為例子</li></ol><pre><code class="hljs JS"><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">//印出小白</span><span class="hljs-comment">/*</span><span class="hljs-comment">    解釋上述程式碼的 創造階段 與 執行階段</span><span class="hljs-comment">    1. 創造階段：myName 變數「提升」，獲得一個記憶體空間，其值是 undefined</span><span class="hljs-comment">    2. 執行階段：myName 變數被賦予值，其值是&#x27;小白&#x27;，console.log(myName) 會將 myName 變數中的值取出來後印出來</span><span class="hljs-comment">*/</span></code></pre><ol start="2"><li>修改一下順序</li></ol><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">// console.log 會印出 undefined，而不是 Uncaught ReferenceError: myName is not defined 的錯誤。</span><span class="hljs-comment">/*</span><span class="hljs-comment">  為什麼不會印出錯誤？myName 變數不是後面才宣告嗎？原因是因為 myName 變數「提升」了！</span><span class="hljs-comment">  在印出來之前，myName 變數已經有了記憶體空間，只是還沒被賦予值，因此是 undefined。</span><span class="hljs-comment">*/</span><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">  1. 創造階段：myName 變數「提升」，獲得一個記憶體空間，其值是 undefined</span><span class="hljs-comment">  2. 執行階段：console.log(myName) 將 myName 變數中的值印出來 ( 先印出 undefined )</span><span class="hljs-comment">              然後 myName 變數才被賦予 &#x27;小白&#x27; 這個值。</span><span class="hljs-comment">*/</span></code></pre><blockquote><p>有了提升的概念之後，在來要討論的是，函式提升與變數提升的不同處。</p></blockquote><h2 id="函式的創造階段與執行階段，與變數相比多了兩個原則："><a href="#函式的創造階段與執行階段，與變數相比多了兩個原則：" class="headerlink" title="函式的創造階段與執行階段，與變數相比多了兩個原則："></a>函式的創造階段與執行階段，與變數相比多了兩個原則：</h2><ul><li>函式在創造階段就已經有完整的記憶體空間</li><li><strong>函式陳述式</strong>優先函式表達式與變數宣告</li></ul><ol><li>舉例</li></ol><pre><code class="hljs JS"><span class="hljs-title function_">callName</span>();<span class="hljs-comment">/*</span><span class="hljs-comment">  callName 函式在比較下面，理論上應該是沒辦法成功執行 callName()，</span><span class="hljs-comment">  但是因為「提升」的機制，使得 callName 函式優先獲得記憶體空間，因此你要在哪裡呼叫都可以</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 下行函式的宣告方式叫做「函式陳述式」</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">callName</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是小明&#x27;</span>);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">    解釋上述程式碼的創造階段與執行階段</span><span class="hljs-comment">    1. 創造階段：callName 函式陳述式優先「提升」，獲得一個記憶體空間</span><span class="hljs-comment">    2. 執行階段：呼叫了 callName() 函式，印出&#x27;我是小明&#x27;</span><span class="hljs-comment">*/</span></code></pre><ol start="2"><li>函式陳述式 v.s 函式表達式 ⇒ 兩者之間的差異在於「提升的方式」不同</li></ol><pre><code class="hljs JS"><span class="hljs-comment">//函式陳述式</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;這是函式陳述式&#x27;</span>);&#125;<span class="hljs-comment">//函式表達式</span><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;這是函式表達式&#x27;</span>);&#125;<span class="hljs-title function_">fn</span>();<span class="hljs-comment">//呼叫 fn 函式，會印出 &#x27;這是函式陳述式&#x27; 還是 &#x27;這是函式表達式呢&#x27;？</span><span class="hljs-comment">/*</span><span class="hljs-comment">    這邊開始解釋「函式陳述式」與「函式表達式」的不同處，</span><span class="hljs-comment">    以上述程式碼為例，列出創造階段與執行階段</span><span class="hljs-comment"></span><span class="hljs-comment">    1. 創造階段：</span><span class="hljs-comment">        function fn()&#123; //函式陳述式優先提升</span><span class="hljs-comment">          console.log(&#x27;這是函式陳述式&#x27;);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        var fn; //fn 變數提升</span><span class="hljs-comment"></span><span class="hljs-comment">    2. 執行階段：</span><span class="hljs-comment">        fn = function()&#123; // fn 被賦予值</span><span class="hljs-comment">          console.log(&#x27;這是函式表達式&#x27;);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        fn(); //呼叫 fn 函式，最終印出&#x27;這是函式表達式&#x27;！！</span><span class="hljs-comment"></span><span class="hljs-comment">    不同之處在於函式表達式會在執行階段才將值(整個function) assign 給 fn 變數，</span><span class="hljs-comment">    進而覆蓋了在創造階段出現的函式陳述式，所以才會印出&#x27;函式表達式&#x27;。</span><span class="hljs-comment">*/</span></code></pre><p>第一次理解 Hoisting 時有點小吃力，<br>不過大腦是一個神奇的東西，隨著時間拉長再回頭看，就知道這是什麼了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 2：變數作用域的範圍</title>
      <link href="/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%202%EF%BC%9A%E8%AE%8A%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%AF%84%E5%9C%8D/"/>
      <url>/2024/07/13/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%202%EF%BC%9A%E8%AE%8A%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%AF%84%E5%9C%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="var、let、const-三者宣告出來的變數作用域差別為何？"><a href="#var、let、const-三者宣告出來的變數作用域差別為何？" class="headerlink" title="var、let、const 三者宣告出來的變數作用域差別為何？"></a>var、let、const 三者宣告出來的變數作用域差別為何？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>var 的作用域範圍在函式內( 所以又稱函式作用域 )，let、const 則屬於區塊作用域，且目前主流的宣告方式皆採用 let、const。</p></blockquote><p>等等，什麼是函式作用域？什麼是區塊作用域？</p><h3 id="函式作用域"><a href="#函式作用域" class="headerlink" title="函式作用域"></a>函式作用域</h3><p>函式作用域的意思就是，變數的生命週期在一個函式內，然後樣子看來起來像這樣：</p><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;    <span class="hljs-comment">// myName 的生命週期僅存在此函式中</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);&#125;<span class="hljs-title function_">fn</span>();<span class="hljs-comment">//印出小白</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// Uncaught ReferenceError: myName is not defined</span></code></pre><h3 id="區塊作用域"><a href="#區塊作用域" class="headerlink" title="區塊作用域"></a>區塊作用域</h3><p>區塊作用域則有下列幾種類型</p><ul><li>函式：function fn() { …… } 區塊作用域是函式作用域的一種</li><li>for 迴圈：for( xxx）{ …… }</li><li>判斷式：if( expression ){ …… }</li><li>純粹的區塊：｛｝</li><li>基本上看到｛｝都可以認定為一個區塊</li></ul><h3 id="好像還看不太出來差別，用以下例子區分"><a href="#好像還看不太出來差別，用以下例子區分" class="headerlink" title="好像還看不太出來差別，用以下例子區分"></a>好像還看不太出來差別，用以下例子區分</h3><ul><li>for 迴圈</li></ul><pre><code class="hljs JS"><span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span>; i++ )&#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<span class="hljs-comment">// 印出 10，抓得到 i 這個值！！</span><span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span> ; j&lt;<span class="hljs-number">10</span>; j++ )&#123;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<span class="hljs-comment">// 印出 Uncaught ReferenceError: j is not defined</span></code></pre><ul><li>for 迴圈</li></ul><pre><code class="hljs JS"><span class="hljs-keyword">if</span>( ..... )&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// 印出小白</span><span class="hljs-keyword">if</span>( ..... )&#123;    <span class="hljs-keyword">let</span> yourName = <span class="hljs-string">&#x27;小葵&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(yourName);<span class="hljs-comment">// 印出 Uncaught ReferenceError: yourName is not defined</span></code></pre><ul><li>純粹的區塊</li></ul><pre><code class="hljs JS">&#123;    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;小白&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// 印出小白</span>&#123;    <span class="hljs-keyword">let</span> yourName = <span class="hljs-string">&#x27;小葵&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(yourName);<span class="hljs-comment">// 印出 Uncaught ReferenceError: yourName is not defined</span></code></pre><p>從上述三個例子中可以發現，<br>區塊作用域的優點會比函式作用域的優點要來得多，<br>因為 var 所宣告的變數，除了在函式中宣告的不會變成全域變數外，其餘都會變成全域變數，<br>這在幾百行幾千行中是非常難以除錯的，因此 let、const 宣告詞才會成為主流。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>變數與作用域 1：全域變數 &amp; 全域屬性</title>
      <link href="/2024/07/12/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%201%EF%BC%9A%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8%20&amp;%20%E5%85%A8%E5%9F%9F%E5%B1%AC%E6%80%A7/"/>
      <url>/2024/07/12/%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%201%EF%BC%9A%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8%20&amp;%20%E5%85%A8%E5%9F%9F%E5%B1%AC%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="為什麼變數需要宣告？能不宣告直接用嗎？"><a href="#為什麼變數需要宣告？能不宣告直接用嗎？" class="headerlink" title="為什麼變數需要宣告？能不宣告直接用嗎？"></a>為什麼變數需要宣告？能不宣告直接用嗎？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>沒有透過「宣告」產生出來的變數，會是一個「全域的 windows 物件底下的一個屬性」。</p></blockquote><p>變數如果不透過 var、let 、const 宣告的話，會變成一個名為 windwos 物件底下的一個屬性，<br>該屬性是一個全域屬性！<br>範例：</p><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">// 注意，a 變數並沒有透過 var、let、const 來宣告，</span>    <span class="hljs-comment">// 卻可以被底下的 fn2() 所使用</span>    a = <span class="hljs-string">&#x27;小明&#x27;</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>)<span class="hljs-comment">// 實際上這個 a 變數是 winsows 物件下的一個屬性</span>&#125;<span class="hljs-title function_">fn1</span>(); <span class="hljs-comment">// 呼叫 fn1()，產生一個具全域屬性 a</span><span class="hljs-title function_">fn2</span>(); <span class="hljs-comment">// 呼叫 fn2()，印出兩次小明</span></code></pre><p>這種沒有透過「宣告」的方式所產生出來的變數，會因為是一個全域屬性的關係，容易被汙染，進而難以 debug。</p><h2 id="那變數與屬性的差異為何？"><a href="#那變數與屬性的差異為何？" class="headerlink" title="那變數與屬性的差異為何？"></a>那變數與屬性的差異為何？</h2><blockquote><p>💡<strong>先講結論</strong>：<br>差異就是只有「屬性」才可以使用 delete 運算子刪除 。</p></blockquote><p>範例：</p><pre><code class="hljs JS">a = <span class="hljs-string">&#x27;小白&#x27;</span>; <span class="hljs-comment">//因為沒有用宣告字，所以會在 windows 物件底下會新增一個屬性叫做 a</span><span class="hljs-keyword">delete</span> a; <span class="hljs-comment">// a 是一個全域屬性，可透過 delete 刪除</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>); <span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span></code></pre><pre><code class="hljs JS"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;小白&#x27;</span>; <span class="hljs-comment">// 雖然是用「宣告的方式」，但 windows 物件底下還是會新增一個屬性叫做 a，</span>                <span class="hljs-comment">// 但透過「宣告的方式」所產生出來的屬性是無法利用 delete 運算子刪除的</span><span class="hljs-keyword">delete</span> a; <span class="hljs-comment">// 無法透過 delete 刪除</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windows.<span class="hljs-property">a</span>); <span class="hljs-comment">//印出小白</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 印出小白</span></code></pre><p>沒使用宣告字宣告的變數 -&gt; 全域屬性，可用 delete 運算子刪除此屬性。<br>使用 var 宣告字宣告的變數 -&gt; 全域變數，無法使用 delete 運算子刪除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 變數與作用域系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/07/12/hello-world/"/>
      <url>/2024/07/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
